---
title: "Myoblast Alternative Splicing Analysis"
author: "Andrés Gordo Ortiz @Al Jord Lab CRG"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    theme: flatly
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    code_folding: hide
    code_download: false
    df_print: paged
    number_sections: true

editor_options:
  markdown:
    wrap: 72

header-includes:
  - '<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">'
  - '<style>
        /* Base styling */
        body {
          font-family: "Roboto", sans-serif;
          color: #333;
          background-color: #ffffff;
          margin: 0;
          padding: 20px;
        }
        .container {
          max-width: 960px;
          margin: auto;
        }
        
        /* Headings */
        h1, h2, h3, h4, h5, h6 {
          color: #2C3E50;
          text-align: center;
          font-weight: 700;
          margin: 0.5em 0;
        }
        h1 { font-size: 2.5em; }
        h2 { font-size: 2em; }
        h3 { font-size: 1.75em; }
        
        /* Text styling */
        p {
          line-height: 1.6;
          margin-bottom: 1em;
          text-align: justify;
        }
        .subtitle, .author, .date {
          text-align: center;
          color: #2C3E50;
          margin-bottom: 0.5em;
        }
        
        /* Links */
        a {
          color: #0275d8;
          text-decoration: none;
        }
        a:hover {
          text-decoration: underline;
        }
        
        /* Tables */
        table {
          width: 100%;
          border-collapse: collapse;
          margin: 20px 0;
        }
        th, td {
          border: 1px solid #ddd;
          padding: 10px;
        }
        th {
          background-color: #2C3E50;
          color: #fff;
        }
        tr:nth-child(even) {
          background-color: #f9f9f9;
        }
        tr:hover {
          background-color: #f1f1f1;
        }
     </style>'
---




```{r setup, include=FALSE}
# Ensure a clean environment and load required libraries.
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)


# Load required libraries
library("betAS")
library("ggplot2")
library("plotly")
library("dplyr")
library("tidyverse")
library("cowplot")
library("DT")
library("paletteer")
library("ggupset")
library("showtext")
library("ggtext")
library("readxl")
library("biomaRt")
library("patchwork")
library("org.Mm.eg.db")
library("org.Hs.eg.db")
library("enrichplot")
library("DOSE")
library("clusterProfiler")
library("ReactomePA")
library("ComplexHeatmap")
library("enrichR")
library("colorRamp2")
library("dendextend")
library("ggrepel")
library("ggVennDiagram")
library("UpSetR")
library("ComplexUpset")

# Register Google fonts
showtext_auto()
font_add_google("Roboto", "roboto")
font="roboto"
```

# Introduction to this Analysis

## Objective

The primary aim is to identify a list of splicing events that meet the following criteria:
1. **Differential Splicing**: Events are differentially spliced during myoblast differentiation.
2. **Spatial Relevance**: Events occur near or around nuclear speckles.
This analysis is structured into two distinct parts, the first performed in the Bash Command     Line, and the second in R. This report shows the second part.

---

## Part 1: Upstream Analysis

The upstream analysis is performed on the CRG cluster using the Bash command line. This phase involves:

1. **Data Acquisition**:
   - Downloading `*.fastq.gz` files from five different databases.

2. **Alignment**:
   - Aligning the sequences to the latest mouse genome release (mm10) using **Bowtie2** through the [Vast-Tools align function](https://link.springer.com/protocol/10.1007/978-1-0716-2521-7_7).

3. **Event Detection**:
   - Importing inclusion tables generated by Vast-Tools into RStudio. The tables cover the following splicing events:
     - **Exons (EX)**
     - **Introns (IN)**
     - **Alternative 5' Splice Sites (Alt5)**
     - **Alternative 3' Splice Sites (Alt3)**
     - **Microexons (MIC)**

---

## Part 2: Statistical Analysis

### Objective
To identify splicing events that are differentially spliced during myoblast differentiation, and sorting them out according to how likely they are found close to nuclear speckles.

### Steps

1. **Statistical Testing**:
   - Use the [betAS package](https://rnajournal.cshlp.org/content/30/4/337) in R to perform:
     - **False Discovery Rate (FDR)**
     - **dPSI**

2. **Filtering Criteria**:
   - Retain events with:
     - **Number of supporting reads across samples >= 10**

3. **Feature Extraction**:
   - Features were obtained through the [VastDB](https://vastdb.crg.eu/) wiki:
     - **CG content**
     - **Sequence length**
     - **5'/3' splice site scores**
   - Gene Ontology related to Nuclear Speckles were obtained from [Wu et al. 2024](https://www.science.org/doi/10.1126/sciadv.adp7727) and [Baructu et al. 2022](https://www.cell.com/molecular-cell/fulltext/S1097-2765(21)01072-8):
     - **Speckles Gene Ontology**
     - **Gene List retained in Speckles**

The final plots showcase potentially promising events found in myoblast differentiation and related to speckles.

---

# Data Availability

| Name         | Publisher               | ENA Link                                                      | Year | Study Specs                                                                                                                                                                          | Details             |
| ------------ | ----------------------- | ------------------------------------------------------------- | ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------- |
| Lingjian Tao | Molecular Biotechnology | [SRP496253](https://www.ebi.ac.uk/ena/browser/view/SRP496253) | 2024 | Myotube formation observed after 4 days, full maturation at 7 days. 3 paired-end biological replicates per condition across 4 timepoints (0, 2, 4, 7 days), totaling 24 fastq files. | \~44M per biosample |
                |

---

## Importing Inclusion Data

```{r inclusion tables}

# Tao et al. 2024 data
tao_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/Tao_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")
tao_events <- filterEvents(getEvents(tao_data, tool = "vast-tools"), N=10) # Extract alternative splicing events
tao_exons <- filterEvents(tao_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 10)
tao_introns <- filterEvents(tao_events, types = c("IR"), N = 10)

```


## Metadata { .tabset}


### Tao

```{r metadata tao}
# Load metadata file containing sample information
metadata_tao <- arrange(read.csv(paste0(getwd(),"/metadata/tao_metadata.csv"), sep = ","), experiment_title)
DT::datatable(metadata_tao, options = list(pageLength = nrow(metadata_tao), scrollX = TRUE))
```


---

# Splicing & Sample Quality Checking

Splicing inclusion plots look like a ***U*** when looking at the *exons*, as normally most of them are spliced out completely (dPSI=0) or constitutively spliced in (dPSI=100), but some of them are in between and those are the most interesting for the analysis. On the other hand, *introns* are ussually not included (that is their definition), but in a few cases they are included. Thus, the intron plot looks like the exponential distribution.



## PCA Plot

As it can be seen, most dataframe sinclude only two conditions; *Myoblasts* or *Myotubes*, where Tao has different time points. However, all of them are clustered properly in the PCA plot. PCA was done on the PSI matrix of each study as they come out from *Vast Combine*.


```{r pca calculation tao, results='hide'}
# Subset and scale data
pca_tao <- na.omit(tao_data[,  c("EVENT",tao_events$Samples)])


rownames(pca_tao)<- pca_tao$EVENT
pca_tao<-t(pca_tao[,-1])

metadata_merged<-tibble(sample=c(metadata_tao$run_accession),experiment_title=c(metadata_tao$experiment_title))

# Reorder metadata_merged$experiment_title based on the row names of merged_pca
condition_pca <- metadata_merged$experiment_title[match(rownames(pca_tao), metadata_merged$sample)]


pca_result <- prcomp(pca_tao)  # Perform PCA

# Prepare PCA results for plotting
pca_data <- as.data.frame(pca_result$x)
pca_data$Sample <- rownames(pca_data)
pca_data$condition<-condition_pca
```

```{r pca plotting tao, warning=FALSE}
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = as.factor(condition))) +
  geom_point(size = 6, alpha = 0.8) +
  labs(
    title = "Principal Component Analysis",
    x = paste("PC1 (", round(100 * summary(pca_result)$importance[2, 1], 1), "%)", sep = ""),
    y = paste("PC2 (", round(100 * summary(pca_result)$importance[2, 2], 1), "%)", sep = "")
  ) +
  scale_colour_paletteer_d("lisa::OskarSchlemmer") +
  theme_minimal(base_family = "Roboto") +
  theme(
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5, margin = margin(b = 10)),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    legend.position = "right",
    legend.title = element_blank(),
    legend.text = element_text(size = 12),
    panel.background = element_rect(fill = "gray98", color = NA),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_blank(),
    plot.caption = element_text(size = 10, hjust = 1, margin = margin(t = 10))
  ) +
  coord_fixed()

pca_plot


```



```{r general stats}
vastdb_events<-read.table("EVENT_INFO-mm10.tab", header = TRUE, sep = "\t")
bin_exons <- function(n) {
  if (is.na(n)) return(NA) # Handle missing values
  else if (n < 6) return("1-5")
  else if (n < 11) return("6-10")
  else if (n < 21) return("11-20")
  else return("21+")
}

#subset vastdb events if they contin the word "EX" in the column EVENT
vastdb_exons<-vastdb_events[grep("EX", vastdb_events$EVENT),]
# Add exon group information
apply_bin_exons <- function(item) {
  gene_counts <- table(item$GENE) # Count exons per gene
  item$exon_group <- sapply(item$GENE, function(gene) bin_exons(gene_counts[gene]))
  item
}

vastdb_exons<-apply_bin_exons(vastdb_exons)

#subset vastdb events if they contin the word "EX" in the column EVENT
vastdb_introns<-vastdb_events[grep("IN", vastdb_events$EVENT),]
# Add exon group information
apply_bin_exons <- function(item) {
  gene_counts <- table(item$GENE) # Count exons per gene
  item$intron_group <- sapply(item$GENE, function(gene) bin_exons(gene_counts[gene]))
  item
}

vastdb_introns<-apply_bin_exons(vastdb_introns)

```


# Does the number of exons of a gene affect Inclusion? { .tabset}

First I classified the genes according to the number of exons they contain from VASTDB. Then I plotted the dPSI of all exons grouped by that classification.

```{r inclusionumber of exons spire, fig.width=12, fig.height=8}
# ---- Prepare Data -----------------------------------------------------------
# Remove rows with NA in any of the columns needed (columns 7, 8, 9, 10)
tao_exons_df <- tao_exons$PSI %>% 
  filter(complete.cases(select(., 7:18)))
tao_exons_df<-tao_exons_df[,c(colnames(tao_exons_df)[1:6],metadata_tao$run_accession)]
# Compute the averages and PSI difference for each row
tao_exons_df <- tao_exons_df %>% 
  mutate(
    avg_4d = rowMeans(select(., 13:15)),
    avg_control = rowMeans(select(., 7:9)),
    difference = avg_4d - avg_control
  ) %>% 
  filter(difference >= 1 | difference <= -1) %>%  # Filter for differences > 10 or < -10
  mutate(group = if_else(difference < 0, "Skipped", "Included"))

# ---- Normality Check -----------------------------------------------------------
# Use a subset of the data if sample size > 5000 for the Shapiro-Wilk test
set.seed(123)  # For reproducibility
if(nrow(tao_exons_df) > 5000) {
  shapiro_sample <- sample(tao_exons_df$difference, 5000)
  shapiro_test <- shapiro.test(shapiro_sample)
} else {
  shapiro_test <- shapiro.test(tao_exons_df$difference)
}

# Choose statistical test based on normality (alpha = 0.05)
if (shapiro_test$p.value > 0.05) {
  test_result <- t.test(tao_exons_df$difference, mu = 0)
  test_used <- "Student's t-test"
} else {
  test_result <- wilcox.test(tao_exons_df$difference, mu = 0)
  test_used <- "Wilcoxon signed-rank test"
}

# Calculate percentages for inclusion and exclusion
pct_below <- round(mean(tao_exons_df$difference < 0) * 100, 1)
pct_above <- round(mean(tao_exons_df$difference > 0) * 100, 1)
n_samples <- nrow(tao_exons_df)

# ---- Plot -------------------------------------------------------------------

plot_psi_distribution <- ggplot(
  tao_exons_df[abs(tao_exons_df$difference) > 0, ], 
  aes(x = difference)
) +
  geom_histogram(
    aes(y = ..density.., fill = difference > 0), 
    bins = 100, position = "identity", alpha = 0.9, color = "black"
  ) +
  labs(
    title = "PSI Difference Distribution of Exons in Spire",
    subtitle = paste(test_used, "p-value:", format(test_result$p.value, digits = 3), "| n:", n_samples),
    x = "ΔPSI (4D - 0D)",
    y = "Density",
    fill = "Splicing Direction"
  ) +
  theme_classic(base_family = "sans") +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 12),
    # Remove grid lines
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_x_continuous(
    breaks = c(-100, -75, -50, -25, 0, 25, 50, 75, 100)
  ) +
  # Assign colors explicitly to match annotations
  scale_fill_manual(
    values = c("#4BA3C3", "#D62839"),
    labels = c("ΔPSI < 0", "ΔPSI > 0")
  ) +
  # Annotate the percentages with polished label boxes
  annotate("label", x = -65, y = 0.1, hjust = 0, vjust = 0,
           label = sprintf("ΔPSI < 0: %.1f%%", pct_below),
           fill = alpha("white", 0.8), color = "#4BA3C3", size = 5, fontface = "bold",
           label.size = 0.5) +
  annotate("label", x = 65, y = 0.1, hjust = 1, vjust = 0,
           label = sprintf("ΔPSI > 0: %.1f%%", pct_above),
           fill = alpha("white", 0.8), color = "#D62839", size = 5, fontface = "bold",
           label.size = 0.5)

# Save and display the plot
ggsave("final_plots/tao_exons_psi_distribution.svg", plot_psi_distribution, width = 12, height = 8, dpi = 300)

print(plot_psi_distribution)
```

```{r skewness tao}
exons_per_gene<-read.table("coding_unique_exon_counts_per_gene.txt")
colnames(exons_per_gene)<-c("gene","exons")
# Connect to Ensembl BioMart for mouse
ensembl <- useMart("ensembl", dataset = "mmusculus_gene_ensembl")

# Retrieve gene symbols
gene_conversion <- getBM(
  attributes = c("mgi_symbol","ensembl_gene_id"),
  filters = "mgi_symbol",
  values = tao_exons_df$GENE,
  mart = ensembl
)

# Merge gene symbols and exon counts
tao_exons_df_number <- tao_exons_df %>%
  left_join(gene_conversion %>% select(mgi_symbol, ensembl_gene_id), by = c("GENE" = "mgi_symbol")) %>%
  left_join(exons_per_gene %>% select(gene, exons), by = c("ensembl_gene_id" = "gene")) %>%
  rename(numb_exons = exons)


library(dplyr)
library(ggplot2)
library(purrr)

set.seed(123)

# 1. Manual skewness
skewness_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

# 2. Bin the data
binned <- tao_exons_df_number %>%
  filter(abs(difference) > 0, !is.na(numb_exons)) %>%
  mutate(
    exon_bin = cut(numb_exons,
                   breaks = c(0, 10, 50, Inf),
                   labels = c("1–10", "11–50", "51+"),
                   right = TRUE)
  ) %>%
  filter(!is.na(exon_bin))

# 3. Bootstrap skewness per bin
boot_results <- binned %>%
  group_by(exon_bin) %>%
  summarise(
    boot_skews = list(replicate(
      1000,
      skewness_manual(sample(difference, replace = TRUE))
    )),
    .groups = "drop"
  ) %>%
  mutate(
    skew_estimate = map_dbl(boot_skews, ~ mean(.x, na.rm = TRUE)),
    ci_lower      = map_dbl(boot_skews, ~ quantile(.x, 0.025, na.rm = TRUE)),
    ci_upper      = map_dbl(boot_skews, ~ quantile(.x, 0.975, na.rm = TRUE)),
    significant   = (ci_lower > 0) | (ci_upper < 0)
  )


# 1. Compute per‐bin stats including manual skewness
skew_manual <- function(x) {
  x <- na.omit(x)
  n <- length(x)
  if (n < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  sum((x - m)^3) / n / (s^3)
}

bin_stats <- tao_exons_df_number %>%
  filter(abs(difference) > 0) %>%
  mutate(
    exon_bin = cut(numb_exons, breaks = c(0,10,50,Inf),
                   labels = c("1–10","11–50","51+"), right = TRUE)
  ) %>%
  filter(!is.na(exon_bin)) %>%
  group_by(exon_bin) %>%
  summarise(
    sample_vec = list(if(n() > 5000) sample(difference,5000) else difference),
    n = n(),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    skewness = skew_manual(sample_vec),
    shapiro_p = shapiro.test(sample_vec)$p.value,
    test_used = if(shapiro_p > .05) "t-test" else "Wilcoxon",
    test_p   = if(test_used=="t-test") t.test(sample_vec,mu=0)$p.value
               else wilcox.test(sample_vec,mu=0)$p.value,
    pct_below = mean(sample_vec < 0)*100,
    pct_above = mean(sample_vec > 0)*100
  ) %>%
  select(exon_bin, n, skewness, test_used, test_p, pct_below, pct_above)



library(ggplot2)
library(dplyr)

# Make sure your font is available:

library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)

font_add_google(name = "Courier Prime", family = "Courier Prime") 
library(showtext)
showtext_auto()
showtext_opts(dpi=600)

boot_long <- boot_results %>%
  mutate(exon_bin = factor(exon_bin,
                           levels = c("1–10", "11–50", "51+"))) %>%
  unnest(boot_skews)

p <- ggplot(boot_results,
            aes(x = exon_bin, y = skew_estimate)) +
  
  # jittered bootstraps
  geom_jitter(data = boot_long,
              aes(fill = exon_bin, y = boot_skews),
              position = position_jitter(width = 0.15, height = 0),
              shape = 21,
              color = "gray30", 
              size = 2,
              alpha = 0.05,
              stroke = 0.8) +

  # polynomial regression (2nd degree)
  geom_smooth(data = boot_long,
              aes(x = as.numeric(exon_bin), y = boot_skews),
              method = "lm", formula = y ~ poly(x, 2),
              se = FALSE,
              linetype = "dashed",
              color = "grey40",    # grey line
              size = 1.5) +        # thicker

  # main points
  geom_point(aes(fill = exon_bin, color = significant, shape = significant),
             size = 4, alpha = 0.9, stroke = 1) +

  scale_fill_manual(values = c(
    "1–10"  = "#d1cbe5",
    "11–50" = "#9671bd",
    "51+"   = "#6a408d"
  ), name = "Exon Bin",
     guide = guide_legend(override.aes = list(shape = 21, 
                                             alpha = 1,
                                             size = 4,
                                             color = "gray30"))) +
            

  # significance aesthetics
  scale_color_manual(values = c(`TRUE`  = "#378d94",
                                `FALSE` = "grey60"),
                     name = "Significant") +
  scale_shape_manual(values = c(`TRUE` = 17, `FALSE` = 16),
                     name = "Significant") +

  # densify grid on y-axis
  scale_y_continuous(
    breaks = pretty_breaks(n = 5),         # fewer major
    minor_breaks = waiver(),               # you can specify seq(min, max, length.out) here
    expand = expansion(add = 0.1)
  ) +

  # densify grid on x-axis
  scale_x_discrete(expand = expansion(add = 0.5)) +

  # labels
  labs(
    title = "Bootstrapped Skewness of Myoblast Splicing",
    x     = "Number of exons per gene",
    y     = "Skewness of ΔPSI Distribution"
  ) +

  # theme tweaks
  # theme tweaks
  theme_minimal(base_family = "Courier Prime") +
  theme(
    aspect.ratio     = 1,
    legend.position  = "top",
    legend.direction = "horizontal",

    # Remove grid lines, but keep the square
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),

    # add a border around the panel
    panel.border     = element_rect(fill = NA,
                                    color = alpha("black", 0.3),
                                    size = 0.5),

    plot.title       = element_text(size = 14, face = "bold", hjust = 0.5),
    axis.title       = element_text(size = 12),
    axis.text        = element_text(size = 10),
  ) +

  # Add a grey line at y = 0
  geom_hline(yintercept = 0, color = "grey50", linetype = "solid", size = 0.5) +
  scale_y_continuous(limits = c(-2, 2.5))

print(p)


ggsave("tao_exons.png",
       plot   = p,
       width  = 6,
       height = 4,
       dpi=600)

```

```{r exon length}
library(ggplot2)
library(ggpubr)
library(showtext)

# → Load Google font
font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()
showtext_opts(dpi = 600)

# → Bin LENGTH into three ordered categories
differential_tao_exons_4d$length_bin <- cut(
    differential_tao_exons_4d$LENGTH,
    breaks = c(-Inf, 27, 50, Inf),
    labels = c("≤27","28–50",">50")
)

# → Define a single‐hue sequential palette (light → dark)
seq_cols <- c("≤27"   = "#c6dbef",
              "28–50" = "#6baed6",
              ">50"   = "#2171b5")

# → Build the boxplot
p <- ggplot(differential_tao_exons_4d, 
            aes(x = length_bin, y = deltapsi, fill = length_bin)) +
  
    geom_hline(yintercept = 0, linetype = 2) +
    
    # Boxplots with transparent fill
    geom_boxplot(alpha = 0.8, outlier.shape = NA, width = 0.7) +
    
    # Pairwise t‐tests with asterisks
    stat_compare_means(
        comparisons = list(
            c("≤27","28–50"),
            c("≤27",">50"),
            c("28–50",">50")
        ),
        method    = "t.test",
        label     = "p.signif",
        hide.ns   = TRUE,
        tip.length = 0.02,
        size=1
    ) +
    
    # Palette, labels
    scale_fill_manual(values = seq_cols, name = "Length bin (nt)") +
    labs(
        title = "ΔPSI by Exon Length Category",
        x     = "Length bin",
        y     = "ΔPSI (D4 - D0)"
    ) +
    
    # Styling inspired by your example
    theme_minimal(base_family = "Courier Prime") +
    theme(
        aspect.ratio     = 1,
        legend.position  = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border     = element_rect(fill = NA,
                                        color = alpha("black", 0.3),
                                        size = 0.5),
        plot.title       = element_text(size = 4, face = "bold", hjust = 0.5),
        axis.title       = element_text(size = 3, face = "bold"),
        axis.text        = element_text(size = 2),
        axis.ticks.length = unit(2, "pt")
    ) +
    
    # Tighter axis expansion
    scale_x_discrete(expand = expansion(add = 0.5)) +
    scale_y_continuous(expand = expansion(add = 0.1)) 

# → Print it
print(p)
```


# Differential Splicing Calculation

```{r aux_featuregroup}
# Extract unique groups and sample IDs
groupingVariable <- "experiment_title"

# Tao
groups_tao <- unique(metadata_tao[, groupingVariable])
samples_tao <- metadata_tao$run_accession


random_colors=c("#D8D97AFF", "#95C36EFF", "#74C8C3FF", "#5A97C1FF", "#295384FF", "#0A2E57FF")


# Create group list with metadata for Tao, Christopher, and Lyu
groupList_tao <- lapply(1:length(groups_tao), function(i) {
  list(
    name = groups_tao[i],
    samples = samples_tao[metadata_tao[, groupingVariable] == groups_tao[i]],
    color = random_colors[i]
  )
})
names(groupList_tao) <- groups_tao


```

```{r groups_auxiliary}
# Define groups
groupA    <- "0_days"
groupB    <- "5_days"
groupA_tao<-"0_days"
groupB_tao<-"7_days"


# For Tao
samplesA_tao <- groupList_tao[[groupA_tao]]$samples
samplesB_tao <- groupList_tao[[groupB_tao]]$samples
colsGroupA_tao <- convertCols(tao_exons$PSI, samplesA_tao)
colsGroupB_tao <- convertCols(tao_exons$PSI, samplesB_tao)



```

## Exon Lists

### Calculations

```{r pdiff calculation}
set.seed(42) #Setting seed for downstream simulations of the beta distribution

groupA_tao<-"0_days"
groupB_tao<-"7_days"
samplesA_tao <- groupList_tao[[groupA_tao]]$samples
samplesB_tao <- groupList_tao[[groupB_tao]]$samples
colsGroupA_tao <- convertCols(tao_exons$PSI, samplesA_tao)
colsGroupB_tao <- convertCols(tao_exons$PSI, samplesB_tao)

# Prepare table for Tao
tao_pdiff_exons <- prepareTableVolcanoFDR(
  psitable = tao_exons$PSI,
  qualtable = tao_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

groupA_tao<-"0_days"
groupB_tao<-"2_days"
samplesA_tao <- groupList_tao[[groupA_tao]]$samples
samplesB_tao <- groupList_tao[[groupB_tao]]$samples
colsGroupA_tao <- convertCols(tao_exons$PSI, samplesA_tao)
colsGroupB_tao <- convertCols(tao_exons$PSI, samplesB_tao)

tao_pdiff_exons_2d <- prepareTableVolcanoFDR(
  psitable = tao_exons$PSI,
  qualtable = tao_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

groupA_tao<-"0_days"
groupB_tao<-"4_days"
samplesA_tao <- groupList_tao[[groupA_tao]]$samples
samplesB_tao <- groupList_tao[[groupB_tao]]$samples
colsGroupA_tao <- convertCols(tao_exons$PSI, samplesA_tao)
colsGroupB_tao <- convertCols(tao_exons$PSI, samplesB_tao)

tao_pdiff_exons_4d <- prepareTableVolcanoFDR(
  psitable = tao_exons$PSI,
  qualtable = tao_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

groupA_tao<-"2_days"
groupB_tao<-"4_days"
samplesA_tao <- groupList_tao[[groupA_tao]]$samples
samplesB_tao <- groupList_tao[[groupB_tao]]$samples
colsGroupA_tao <- convertCols(tao_exons$PSI, samplesA_tao)
colsGroupB_tao <- convertCols(tao_exons$PSI, samplesB_tao)

tao_pdiff_exons_4dvs2d <- prepareTableVolcanoFDR(
  psitable = tao_exons$PSI,
  qualtable = tao_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

groupA_tao<-"4_days"
groupB_tao<-"7_days"
samplesA_tao <- groupList_tao[[groupA_tao]]$samples
samplesB_tao <- groupList_tao[[groupB_tao]]$samples
colsGroupA_tao <- convertCols(tao_exons$PSI, samplesA_tao)
colsGroupB_tao <- convertCols(tao_exons$PSI, samplesB_tao)

tao_pdiff_exons_7dvs4d <- prepareTableVolcanoFDR(
  psitable = tao_exons$PSI,
  qualtable = tao_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)


write.csv(tao_pdiff_exons, "tao_pdiff_exons.csv")
write.csv(tao_pdiff_exons_2d,"tao_pdiff_exons_2d.csv")
write.csv(tao_pdiff_exons_4d,"tao_pdiff_exons_4d.csv")
write.csv(tao_pdiff_exons_4dvs2d,"tao_pdiff_exons_4dvs2d.csv")


groupA_tao<-"0_days"
groupB_tao<-"7_days"
samplesA_tao <- groupList_tao[[groupA_tao]]$samples
samplesB_tao <- groupList_tao[[groupB_tao]]$samples
colsGroupA_tao <- convertCols(tao_introns$PSI, samplesA_tao)
colsGroupB_tao <- convertCols(tao_introns$PSI, samplesB_tao)


# Prepare table for Tao
tao_pdiff_introns <- prepareTableVolcanoFDR(
  psitable = tao_introns$PSI,
  qualtable = tao_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

groupA_tao<-"0_days"
groupB_tao<-"2_days"
samplesA_tao <- groupList_tao[[groupA_tao]]$samples
samplesB_tao <- groupList_tao[[groupB_tao]]$samples
colsGroupA_tao <- convertCols(tao_introns$PSI, samplesA_tao)
colsGroupB_tao <- convertCols(tao_introns$PSI, samplesB_tao)

tao_pdiff_introns_2d <- prepareTableVolcanoFDR(
  psitable = tao_introns$PSI,
  qualtable = tao_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

groupA_tao<-"0_days"
groupB_tao<-"4_days"
samplesA_tao <- groupList_tao[[groupA_tao]]$samples
samplesB_tao <- groupList_tao[[groupB_tao]]$samples
colsGroupA_tao <- convertCols(tao_introns$PSI, samplesA_tao)
colsGroupB_tao <- convertCols(tao_introns$PSI, samplesB_tao)

tao_pdiff_introns_4d <- prepareTableVolcanoFDR(
  psitable = tao_introns$PSI,
  qualtable = tao_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)

groupA_tao<-"2_days"
groupB_tao<-"4_days"
samplesA_tao <- groupList_tao[[groupA_tao]]$samples
samplesB_tao <- groupList_tao[[groupB_tao]]$samples
colsGroupA_tao <- convertCols(tao_introns$PSI, samplesA_tao)
colsGroupB_tao <- convertCols(tao_introns$PSI, samplesB_tao)

tao_pdiff_introns_4dvs2d <- prepareTableVolcanoFDR(
  psitable = tao_introns$PSI,
  qualtable = tao_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim=1000,
  seed = TRUE,
  CoverageWeight = FALSE
)



write.csv(tao_pdiff_introns, "tao_pdiff_introns.csv")
write.csv(tao_pdiff_introns_2d,"tao_pdiff_introns_2d.csv")
write.csv(tao_pdiff_introns_4d,"tao_pdiff_introns_4d.csv")
write.csv(tao_pdiff_introns_4dvs2d,"tao_pdiff_introns_4dvs2d.csv")

```




### FDR Volcano Plots { .tabset}

Volcano Plots of the FDR corrected exons for each study. In pink are the exons with a deltaPSI>=0.1.



#### Tao

```{r tao fdr volcano 4 days}
# INtersecting dhared exons between 10mm vs control and 1mm vs control
differential_tao_exons_4d<-na.omit(tao_pdiff_exons_4d[tao_pdiff_exons_4d$FDR<=0.05 & abs(tao_pdiff_exons_4d$deltapsi)>=0.1,])
differential_tao_exons_2d<-na.omit(tao_pdiff_exons_2d[tao_pdiff_exons_2d$FDR<=0.05 & abs(tao_pdiff_exons_2d$deltapsi)>=0.1,])
differential_tao_exons_4d_2d<-na.omit(tao_pdiff_exons_4dvs2d[tao_pdiff_exons_4dvs2d$FDR<=0.05 & abs(tao_pdiff_exons_4dvs2d$deltapsi)>=0.1,])
differential_tao_exons<-na.omit(tao_pdiff_exons[tao_pdiff_exons$FDR<=0.05 & abs(tao_pdiff_exons$deltapsi)>=0.1,])
differential_tao_exons_7d<-na.omit(tao_pdiff_exons[tao_pdiff_exons$FDR<=0.05 & abs(tao_pdiff_exons$deltapsi)>=0.1,])


shared_exons<-differential_tao_exons_4d$EVENT[differential_tao_exons_4d$EVENT %in% differential_tao_exons_2d$EVENT]


# Volcano plot
tao_pdiff_exons_4d<-na.omit(tao_pdiff_exons_4d)
# Add a Shared column based on the shared_exons
tao_pdiff_exons_4d$Shared <- ifelse(tao_pdiff_exons_4d$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
tao_pdiff_exons_4d$Significant <- ifelse(
  tao_pdiff_exons_4d$FDR<=0.05 & tao_pdiff_exons_4d$deltapsi >= 0.1, "Included",
  ifelse(
    tao_pdiff_exons_4d$FDR<=0.05 & tao_pdiff_exons_4d$deltapsi <= -0.1, "Skipped",
    "Not Significant"
  )
)

tao_pdiff_exons_4d$Significant<-factor(tao_pdiff_exons_4d$Significant, levels=c("Included","Skipped","Not Significant"))
# Convert FDR to -log10 scale for y-axis
tao_pdiff_exons_4d$negLogpvalue <- -log10(tao_pdiff_exons_4d$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tao_pdiff_exons_4d <- tao_pdiff_exons_4d %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Load necessary libraries for font
library(ggplot2)
library(showtext)
library(sysfonts)

# Add Courier Prime font from Google Fonts
font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()
showtext_opts(dpi = 300)


# Build the volcano plot with Courier Prime font
volcano_plot <- ggplot(tao_pdiff_exons_4d, aes(x = deltapsi)) +
  geom_point(data = filter(tao_pdiff_exons_4d, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  geom_point(data = filter(tao_pdiff_exons_4d, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  scale_color_manual(values = c(
    "Included" = "#D62839",
    "Skipped" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Included" = 0.6,
    "Skipped" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Included" = 3,
    "Skipped" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "ΔPSI",
    y = expression(-log[10](FDR)),
    title = "Exons: D4 vs D0",
  ) +
  theme_minimal(base_size = 14, base_family = "Courier Prime") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 15, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 16, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 14, color = "black"),
    axis.title = element_text(size = 16, face = "bold", color = "black"),
    legend.text = element_text(size = 14),
    legend.title = element_blank(),
    legend.position = "top",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Ensure your plot is stored in the variable `volcano_plot`
# Export at 540x280 px at 300 dpi using ggsave

ggsave(
  filename = "volcano_plot_exons_4d.png",
  plot = volcano_plot,
  width = 1640 / 300,     # inches
  height = 1180 / 300,    # inches
  dpi = 300,
  units = "in",
  bg = "white"
)


volcano_plot
```

```{r tao fdr volcano 2 days}
tao_pdiff_exons_2d<-na.omit(tao_pdiff_exons_2d)
# Add a Shared column based on the shared_exons
tao_pdiff_exons_2d$Shared <- ifelse(tao_pdiff_exons_2d$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
tao_pdiff_exons_2d$Significant <- ifelse(
  tao_pdiff_exons_2d$FDR<=0.05 & tao_pdiff_exons_2d$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tao_pdiff_exons_2d$FDR<=0.05 & tao_pdiff_exons_2d$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tao_pdiff_exons_2d$negLogpvalue <- -log10(tao_pdiff_exons_2d$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tao_pdiff_exons_2d <- tao_pdiff_exons_2d %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tao_pdiff_exons_2d, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tao_pdiff_exons_2d, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tao_pdiff_exons_2d, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (2days - 0days)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Myoblast Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14) +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_exons_2d.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

```{r tao fdr volcano 4 to 2 days}
tao_pdiff_exons_4dvs2d<-na.omit(tao_pdiff_exons_4dvs2d)
# Add a Shared column based on the shared_exons
tao_pdiff_exons_4dvs2d$Shared <- ifelse(tao_pdiff_exons_4dvs2d$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
tao_pdiff_exons_4dvs2d$Significant <- ifelse(
  tao_pdiff_exons_4dvs2d$FDR<=0.05 & tao_pdiff_exons_4dvs2d$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tao_pdiff_exons_4dvs2d$FDR<=0.05 & tao_pdiff_exons_4dvs2d$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tao_pdiff_exons_4dvs2d$negLogpvalue <- -log10(tao_pdiff_exons_4dvs2d$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tao_pdiff_exons_4dvs2d <- tao_pdiff_exons_4dvs2d %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tao_pdiff_exons_4dvs2d, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tao_pdiff_exons_4dvs2d, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tao_pdiff_exons_4dvs2d, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (4days - 2days)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Myoblast Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14) +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_exons_4dvs2d.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```


```{r tao fdr volcano 7 to 0 days}
tao_pdiff_exons<-na.omit(tao_pdiff_exons)
# Add a Shared column based on the shared_exons
tao_pdiff_exons$Shared <- ifelse(tao_pdiff_exons$EVENT %in% shared_exons, "Shared", "Not Shared")

# Classify significance
tao_pdiff_exons$Significant <- ifelse(
  tao_pdiff_exons$FDR<=0.05 & tao_pdiff_exons$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tao_pdiff_exons$FDR<=0.05 & tao_pdiff_exons$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tao_pdiff_exons$negLogpvalue <- -log10(tao_pdiff_exons$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tao_pdiff_exons <- tao_pdiff_exons %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tao_pdiff_exons, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tao_pdiff_exons, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tao_pdiff_exons, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (7days - 0days)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Myoblast Exons",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14) +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_exons_7dvs0d.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

### Individual Combination Tables { .tabset}

These tables show the Exons that show a FDR<=0.05 |dPSI|>=0.1 in the pairwise comparison.

#### Tao 4 vs 0


```{r tao combination table}
# Render DataTable with enhancements
datatable(
  differential_tao_exons_4d,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


```


## Intron Lists


### FDR Volcano Plots { .tabset}



#### Tao

```{r tao fdr volcano 4 days int}
# INtersecting dhared introns between 10mm vs control and 1mm vs control
differential_tao_introns_4d<-na.omit(tao_pdiff_introns_4d[tao_pdiff_introns_4d$FDR<=0.05 & abs(tao_pdiff_introns_4d$deltapsi)>=0.1,])
differential_tao_introns_2d<-na.omit(tao_pdiff_introns_2d[tao_pdiff_introns_2d$FDR<=0.05 & abs(tao_pdiff_introns_2d$deltapsi)>=0.1,])
differential_tao_introns_4d_2d<-na.omit(tao_pdiff_introns_4dvs2d[tao_pdiff_introns_4dvs2d$FDR<=0.05 & abs(tao_pdiff_introns_4dvs2d$deltapsi)>=0.1,])

differential_tao_introns_7d<-na.omit(tao_pdiff_introns[tao_pdiff_introns$FDR<=0.05 & abs(tao_pdiff_introns$deltapsi)>=0.1,])


shared_introns<-differential_tao_introns_4d$EVENT[differential_tao_introns_4d$EVENT %in% differential_tao_introns_2d$EVENT]

# Volcano plot
library(ggrepel)
tao_pdiff_introns_4d<-na.omit(tao_pdiff_introns_4d)
# Add a Shared column based on the shared_introns
tao_pdiff_introns_4d$Shared <- ifelse(tao_pdiff_introns_4d$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
tao_pdiff_introns_4d$Significant <- ifelse(
  tao_pdiff_introns_4d$FDR<=0.05 & tao_pdiff_introns_4d$deltapsi >= 0.1, "Retained",
  ifelse(
    tao_pdiff_introns_4d$FDR<=0.05 & tao_pdiff_introns_4d$deltapsi <= -0.1, "Skipped",
    "Not Significant"
  )
)

tao_pdiff_introns_4d$Significant<-factor(tao_pdiff_introns_4d$Significant, levels=c("Retained", "Skipped", "Not Significant"))
# Convert FDR to -log10 scale for y-axis
tao_pdiff_introns_4d$negLogpvalue <- -log10(tao_pdiff_introns_4d$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tao_pdiff_introns_4d <- tao_pdiff_introns_4d %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Load necessary libraries for font
library(ggplot2)
library(showtext)
library(sysfonts)

# Add Courier Prime font from Google Fonts
font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()
showtext_opts(dpi = 300)


# Build the volcano plot with Courier Prime font
volcano_plot <- ggplot(tao_pdiff_introns_4d, aes(x = deltapsi)) +
  geom_point(data = filter(tao_pdiff_introns_4d, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  geom_point(data = filter(tao_pdiff_introns_4d, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  scale_color_manual(values = c(
    "Retained" = "#D62839",
    "Skipped" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Retained" = 0.6,
    "Skipped" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Retained" = 3,
    "Skipped" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "ΔPSI",
    y = expression(-log[10](FDR)),
    title = "Introns: D4 vs D0",
  ) +
  theme_minimal(base_size = 14, base_family = "Courier Prime") +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size =15, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 16, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 14, color = "black"),
    axis.title = element_text(size = 16, face = "bold", color = "black"),
    legend.text = element_text(size = 14),
    legend.title = element_blank(),
    legend.position = "top",
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )

# Ensure your plot is stored in the variable `volcano_plot`
# Export at 540x280 px at 300 dpi using ggsave

ggsave(
  filename = "volcano_plot_introns_4d.png",
  plot = volcano_plot,
  width = 1640 / 300,     # inches
  height = 1180 / 300,    # inches
  dpi = 300,
  units = "in",
  bg = "white"
)

volcano_plot

```


```{r tao fdr volcano 2 days int}

# Volcano plot
library(ggrepel)
tao_pdiff_introns_2d<-na.omit(tao_pdiff_introns_2d)
# Add a Shared column based on the shared_introns
tao_pdiff_introns_2d$Shared <- ifelse(tao_pdiff_introns_2d$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
tao_pdiff_introns_2d$Significant <- ifelse(
  tao_pdiff_introns_2d$FDR<=0.05 & tao_pdiff_introns_2d$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tao_pdiff_introns_2d$FDR<=0.05 & tao_pdiff_introns_2d$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tao_pdiff_introns_2d$negLogpvalue <- -log10(tao_pdiff_introns_2d$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tao_pdiff_introns_2d <- tao_pdiff_introns_2d %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tao_pdiff_introns_2d, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tao_pdiff_introns_2d, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tao_pdiff_introns_2d, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (2days - 0days)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Myoblast Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14) +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_introns_2d.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot

```

```{r tao fdr volcano 4 to 2 days int}

# Volcano plot
library(ggrepel)
tao_pdiff_introns_4dvs2d<-na.omit(tao_pdiff_introns_4dvs2d)
# Add a Shared column based on the shared_introns
tao_pdiff_introns_4dvs2d$Shared <- ifelse(tao_pdiff_introns_4dvs2d$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
tao_pdiff_introns_4dvs2d$Significant <- ifelse(
  tao_pdiff_introns_4dvs2d$FDR<=0.05 & tao_pdiff_introns_4dvs2d$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tao_pdiff_introns_4dvs2d$FDR<=0.05 & tao_pdiff_introns_4dvs2d$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tao_pdiff_introns_4dvs2d$negLogpvalue <- -log10(tao_pdiff_introns_4dvs2d$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tao_pdiff_introns_4dvs2d <- tao_pdiff_introns_4dvs2d %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tao_pdiff_introns_4dvs2d, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tao_pdiff_introns_4dvs2d, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tao_pdiff_introns_4dvs2d, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (4days - 2days)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Myoblast Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14) +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_introns_4dvs2d.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```
```{r tao fdr volcano 7 to 0 days int}

# Volcano plot
library(ggrepel)
tao_pdiff_introns<-na.omit(tao_pdiff_introns)
# Add a Shared column based on the shared_introns
tao_pdiff_introns$Shared <- ifelse(tao_pdiff_introns$EVENT %in% shared_introns, "Shared", "Not Shared")

# Classify significance
tao_pdiff_introns$Significant <- ifelse(
  tao_pdiff_introns$FDR<=0.05 & tao_pdiff_introns$deltapsi >= 0.1, "Overrepresented",
  ifelse(
    tao_pdiff_introns$FDR<=0.05 & tao_pdiff_introns$deltapsi <= -0.1, "Underrepresented",
    "Not Significant"
  )
)

# Convert FDR to -log10 scale for y-axis
tao_pdiff_introns$negLogpvalue <- -log10(tao_pdiff_introns$FDR)

# Define your maximum displayed y-value (the cap)
max_y <- 2

# Pre-process the data:
#  - Create plot_y: if negLogpvalue is infinite (FDR == 0) or > max_y, use max_y.
#  - Flag these points in is_capped.
#  - For capped points only, create a new y-value (plot_y_jitter)
#    that subtracts a small random offset so they don't completely overlap.
set.seed(123)  # for reproducibility of the jitter
tao_pdiff_introns <- tao_pdiff_introns %>%
  mutate(
    plot_y = ifelse(is.infinite(negLogpvalue) | negLogpvalue > max_y, max_y, negLogpvalue),
    is_capped = (is.infinite(negLogpvalue) | negLogpvalue > max_y),
    # Apply a small downward jitter (up to -0.1) only to capped points
    plot_y_jitter = ifelse(is_capped, max_y - runif(n(), 0, 0.1), plot_y)
  )

# Build the volcano plot:
volcano_plot <- ggplot(tao_pdiff_introns, aes(x = deltapsi)) +
  # Layer for non-capped points (displayed at their true y-values)
  geom_point(data = filter(tao_pdiff_introns, !is_capped),
             aes(y = plot_y, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant)) +
  # Layer for capped points: keep them as circles, but use jittered y-values
  geom_point(data = filter(tao_pdiff_introns, is_capped),
             aes(y = plot_y_jitter, 
                 color = Significant, 
                 alpha = Significant, 
                 size = Significant),
             stroke = 0.5,
             show.legend = FALSE) +  
  # Define the color scales
  scale_color_manual(values = c(
    "Overrepresented" = "#D62839",
    "Underrepresented" = "#4BA3C3",
    "Not Significant" = "gray"
  )) +
  scale_alpha_manual(values = c(
    "Overrepresented" = 0.6,
    "Underrepresented" = 0.6,
    "Not Significant" = 0.3
  )) +
  scale_size_manual(values = c(
    "Overrepresented" = 3,
    "Underrepresented" = 3,
    "Not Significant" = 2
  )) +
  scale_x_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 0.5)
  ) +
  # Keep the y-axis fixed from 0 to max_y. Also, modify the top label to show "≥2"
  scale_y_continuous(
    limits = c(0, max_y),
    expand = c(0, 0),
    labels = function(x) ifelse(x == max_y, paste0("≥", max_y), x)
  ) +
  labs(
    x = "Delta PSI (7days - 0days)",
    y = expression(-log[10](FDR)),
    title = "Volcano Plot of Myoblast Introns",
    subtitle = "Significant events are highlighted"
  ) +
  theme_minimal(base_size = 14) +  
  theme(
    plot.title = element_text(
      hjust = 0.5, size = 18, face = "bold", color = "black"
    ),
    plot.subtitle = element_text(
      hjust = 0.5, size = 14, face = "italic", color = "gray30"
    ),
    axis.text = element_text(size = 12, color = "black"),
    axis.title = element_text(size = 14, face = "bold", color = "black"),
    legend.text = element_text(size = 12),
    legend.title = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.line = element_line(color = "black")
  )


# Save as SVG with dimensions 606 x 396
ggsave("volcano_introns_7d.svg", plot = volcano_plot, width = 606/72, height = 396/72, dpi = 72)

volcano_plot
```

### Individual Combination Tables { .tabset}

These tables show the Introns that show a FDR<=0.05 and PDiff (1-pvalue)>=0.95 in the pairwise comparison of Myotubes-Myoblasts, for each study.


#### Tao


```{r tao combination intron table}
# Render DataTable with enhancements
datatable(
  tao_intron_combination_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

```





```{r loading data from vastdb}
events_info<-read.table("EVENT_INFO-mm10.tab", header = TRUE, sep = "\t")
splice_scores<-read.table("SPLICE_SITE_SCORES-mm10.tab", header = FALSE, sep = "\t")
```

# Basic Stats on Found Events

## Events-level stats

```{r basic stats, fig.width=12, fig.height=6}
# Load required libraries
library(UpSetR)
library(tidyverse)
library(grid)      # For adding custom text (titles) to plots
library(showtext)  # For custom fonts
font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()

extract_significant_events <- function(data) {
  filter(data, FDR <= 0.05 & abs(deltapsi) >= 0.1)$EVENT
}
### EXONS ###

# Extract significant events
event_list_exons <- rev(list(
  "D2 vs D0" = extract_significant_events(tao_pdiff_exons_2d),
  "D4 vs D0" = extract_significant_events(tao_pdiff_exons_4d),
  "D7 vs D0" = extract_significant_events(tao_pdiff_exons)
))
binary_matrix_exons <- fromList(event_list_exons)

# UpSet plot with adapted styling
UpSetR::upset(
  binary_matrix_exons,
  sets = names(event_list_exons),
  sets.bar.color = "#007ba6",  # Matching deepest purple from ggplot
  order.by = "freq",
  mainbar.y.label = "Shared Event Count",
  sets.x.label = "Total Significant Events",
  keep.order = TRUE,
  text.scale = c(1.5, 1.5, 1.2, 1.2, 1.4, 1.4),  # Adjust for balance
  mb.ratio = c(0.65, 0.35),     # Better aspect ratio
  matrix.color = "gray30",      # Match jitter color from ggplot
  main.bar.color = "#0099cd",   # Intermediate purple from ggplot
  point.size = 3,
  line.size = 0.8
)

# Title using consistent font and positioning
grid.text("Intersection of Significant Exon Events", 
          x = 0.5, y = 0.98,
          gp = gpar(fontsize = 14, fontface = "bold", 
                    fontfamily = "Courier Prime"))

### INTRONS ###

# Extract significant events
event_list_introns <- rev(list(
  "D2 vs D0" = extract_significant_events(tao_pdiff_introns_2d),
  "D4 vs D0" = extract_significant_events(tao_pdiff_introns_4d),
  "D7 vs D0" = extract_significant_events(tao_pdiff_introns)
))
binary_matrix_introns <- fromList(event_list_introns)

# UpSet plot with adapted styling
UpSetR::upset(
  binary_matrix_introns,
  sets = names(event_list_introns),
  sets.bar.color = "#6a408d",
  order.by = "freq",
  mainbar.y.label = "Shared Event Count",
  sets.x.label = "Total Significant Events",
  keep.order = TRUE,
  text.scale = c(1.5, 1.5, 1.2, 1.2, 1.4, 1.4),
  mb.ratio = c(0.65, 0.35),
  matrix.color = "gray30",
  main.bar.color = "#9671bd",
  point.size = 3,
  line.size = 0.8
)

grid.text("Intersection of Significant Intron Events", 
          x = 0.5, y = 0.98,
          gp = gpar(fontsize = 14, fontface = "bold", 
                    fontfamily = "Courier Prime"))

```


```{r gc}

library(dplyr)
library(ggplot2)
library(ggpubr)  # For stat_compare_means

# Load event info
event_info <- read.delim("EVENT_INFO-mm10.tab")

# GC content function
gc_content <- function(seqs) {
    sapply(seqs, function(seq) {
        seq <- toupper(seq)
        gc <- sum(strsplit(seq, "")[[1]] %in% c("G", "C"))
        total <- nchar(seq)
        if (total == 0) return(NA)
        return(100 * gc / total)
    })
}

# Compute GC content and join
introns_gc <- differential_tao_introns_4d %>%
    left_join(select(event_info, EVENT, Seq_A, LE_o), by = "EVENT") %>%
    mutate(
        gc = gc_content(Seq_A),
        skipped = factor(deltapsi < 0, levels = c(TRUE, FALSE), labels = c("Skipped", "Included"))
    )

# 1) Register and load Courier Prime
font_add_google("Courier Prime", "courierprime")
showtext_auto()

# Common theme for both plots
pub_theme <- theme_minimal(base_family = "courierprime", base_size = 16) +
    theme(
        legend.position   = "none",
        plot.title        = element_text(hjust = 0.5, size = rel(1.2), face = "bold"),
        axis.title        = element_text(size = rel(1.1)),
        axis.text         = element_text(size = rel(1.0)),
        panel.grid.major  = element_line(size = 0.2, color = "grey80"),
        panel.grid.minor  = element_blank()
    )

# 2) GC Content boxplot + jitter
p1 <- ggplot(introns_gc, aes(x = skipped, y = gc, fill = skipped)) +
    geom_boxplot(outlier.shape = NA, alpha = 0.8, width = 0.6) +
    geom_jitter(width = 0.15, alpha = 0.4, size = 1.5) +
    stat_compare_means(
        method    = "wilcox.test",
        label.y   = max(introns_gc$gc, na.rm = TRUE) + 1.5,
        label.size= 5,
        family    = "courierprime"
    ) +
    scale_fill_manual(values = c("#D55E00", "#0072B2")) +
    labs(
        x     = "Splicing Outcome",
        y     = "GC Content (%)",
        title = "GC Content of Introns by Splicing Outcome"
    ) +
    pub_theme

# 3) Length boxplot + jitter, marking 95th‑percentile outliers
# threshold for outliers
threshold <- quantile(introns_gc$LE_o, 0.95, na.rm = TRUE)

main_data <- introns_gc %>% filter(LE_o <= threshold)
outliers  <- introns_gc %>% filter(LE_o >  threshold)

p2 <- ggplot(main_data, aes(x = skipped, y = LE_o, fill = skipped)) +
    geom_boxplot(outlier.shape = NA, alpha = 0.8, width = 0.6) +
    geom_jitter(width = 0.15, alpha = 0.4, size = 1.5) +
    # draw outliers just above the threshold line
    geom_point(
        data     = outliers,
        aes(x = skipped, y = threshold + 2),
        position = position_jitter(width = 0.15),
        shape    = 21,
        size     = 3,
        fill     = "black",
        alpha    = 0.6
    ) +
    stat_compare_means(
        method     = "wilcox.test",
        label.y    = threshold + 7,
        label.size = 5,
        family     = "courierprime"
    ) +
    coord_cartesian(ylim = c(min(main_data$LE_o, na.rm = TRUE), threshold + 8)) +
    scale_fill_manual(values = c("#D55E00", "#0072B2")) +
    labs(
        x     = "Splicing Outcome",
        y     = "Intron Length (nt)",
        title = "Length of Introns by Splicing Outcome"
    ) +
    pub_theme

# 4) Print both plots side by side
library(gridExtra)
grid.arrange(p1, p2, ncol = 2)

```

## Gene-level stats

```{r, basic gene stats, fig.width=12, fig.height=8}

# Load required libraries
library(UpSetR)
library(tidyverse)
library(grid)  # For adding custom text (titles) to plots

### EXONS ###

# Define a function to extract significant events
extract_significant_events <- function(data) {
  filter(data, FDR <= 0.05 & abs(deltapsi) >= 0.1)$GENE
}

# Create a named list of significant events per comparison with improved labels
gene_list <- rev(list(
  "Day 2 vs Day 0" = extract_significant_events(tao_pdiff_exons_2d),
  "Day 4 vs Day 0" = extract_significant_events(tao_pdiff_exons_4d),
  "Day 7 vs Day 0" = extract_significant_events(tao_pdiff_exons)
))

# Convert to a binary presence/absence matrix
binary_matrix_genes <- fromList(gene_list)

# Generate an UpSet plot for exons with improved aesthetics
UpSetR::upset(
  binary_matrix_genes,
  sets = names(gene_list),
  sets.bar.color = "#0099ce",
  order.by = "freq",
  mainbar.y.label = "Shared Gene Count",
  sets.x.label = "Total Significant Genes",
  keep.order = TRUE,
  text.scale = c(1.8, 1.8, 1.8, 1.8, 1.8, 1.8)  # Increase font sizes
)

# Add a main title for the exons plot
grid.text("Intersection of Significantly Spliced Genes", 
          x = 0.5, y = 0.98, 
          gp = gpar(fontsize = 20, fontface = "bold"))


```


# Sorting Out according to features

```{r gc content function}
calculate_GC_percent <- function(df, sequence_column) {
  # Ensure the specified column exists
  if (!sequence_column %in% colnames(df)) {
    stop("The specified column does not exist in the dataframe.")
  }

  # Function to calculate GC content for a single sequence
  gc_content <- function(sequence) {
    # Count G and C in the sequence
    gc_count <- sum(tolower(strsplit(sequence, NULL)[[1]]) %in% c('g', 'c'))
    # Calculate the GC percentage
    gc_percentage <- (gc_count / nchar(sequence)) * 100
    return(gc_percentage)
  }

  # Apply the GC content function to each row's sequence
  df$GC_percent <- sapply(df[[sequence_column]], gc_content)

  return(df)
}
```

```{r splice score site extraction function}
# Function to extract V3 values based on EVENT
extract_V3_for_event <- function(event_value, splice_scores) {
  # Filter rows where V1 matches the event_value
  filtered_rows <- splice_scores %>%
    filter(V1 == event_value)

  # Extract the V3 column and return as a list
  return(list(filtered_rows$V3))
}

```


```{r final list features extraction}
# Exon List features
differential_tao_exons_4d$sequence<-events_info$Seq_A[match(differential_tao_exons_4d$EVENT, events_info$EVENT)]

differential_tao_exons_4d$splice_scores <- apply(differential_tao_exons_4d, 1, function(row) {
  # Get the event value from the current row
  event_value <- row["EVENT"]

  # Call the function to extract the V3 values
  extract_V3_for_event(event_value, splice_scores)
})

# Unnest the list in V3_values into two separate columns
differential_tao_exons_4d <- differential_tao_exons_4d %>%
  unnest(cols = splice_scores) %>%
  separate(splice_scores, into = c("splice_score_3", "splice_score_5"), sep = ",")

# If necessary, clean up the new columns
differential_tao_exons_4d$splice_score_3 <- gsub("[c()]", "", differential_tao_exons_4d$splice_score_3)
differential_tao_exons_4d$splice_score_5 <- gsub("[c()]", "", differential_tao_exons_4d$splice_score_5)
differential_tao_exons_4d$splice_score_3 <- as.numeric(differential_tao_exons_4d$splice_score_3)
differential_tao_exons_4d$splice_score_5 <- as.numeric(differential_tao_exons_4d$splice_score_5)

differential_tao_exons_4d<-calculate_GC_percent(differential_tao_exons_4d,"sequence")

# Intron List features
differential_tao_introns_4d$sequence<-events_info$Seq_A[match(differential_tao_introns_4d$EVENT, events_info$EVENT)]

differential_tao_introns_4d$splice_scores <- apply(differential_tao_introns_4d, 1, function(row) {
  # Get the event value from the current row
  event_value <- row["EVENT"]

  # Call the function to extract the V3 values
  extract_V3_for_event(event_value, splice_scores)
})

# Unnest the list in V3_values into two separate columns
differential_tao_introns_4d <- differential_tao_introns_4d %>%
  unnest(cols = splice_scores) %>%
  separate(splice_scores, into = c("splice_score_3", "splice_score_5"), sep = ",")

# If necessary, clean up the new columns
differential_tao_introns_4d$splice_score_3 <- gsub("[c()]", "", differential_tao_introns_4d$splice_score_3)
differential_tao_introns_4d$splice_score_5 <- gsub("[c()]", "", differential_tao_introns_4d$splice_score_5)
differential_tao_introns_4d$splice_score_3 <- as.numeric(differential_tao_introns_4d$splice_score_3)
differential_tao_introns_4d$splice_score_5 <- as.numeric(differential_tao_introns_4d$splice_score_5)

differential_tao_introns_4d<-calculate_GC_percent(differential_tao_introns_4d,"sequence")

```




## Enrichment Analysis with EnrichR of Candidate Genes { .tabset}


```{r pladb enrichr}

library(clusterProfiler)
library(org.Mm.eg.db)  # Use the appropriate annotation package for your species
library(DOSE)
library(AnnotationDbi)

gene<-AnnotationDbi::select(org.Mm.eg.db,
                            keys = unique(c(differential_tao_exons_4d$GENE,differential_tao_introns_4d$GENE)),
                                         keytype = "SYMBOL", 
                                         columns = "ENTREZID")
gene<-unique(na.omit(gene$ENTREZID))
universe<-AnnotationDbi::select(org.Mm.eg.db,
                            keys = tao_events$PSI$GENE[!tao_events$PSI$GENE %in% unique(c(differential_tao_exons_4d$GENE,differential_tao_introns_4d$GENE))],
                                         keytype = "SYMBOL", 
                                         columns = "ENTREZID")
universe<-unique(na.omit(universe$ENTREZID))
enrichdata <- enrichGO(
  gene          = gene, 
  universe      = universe,  # Custom background
  OrgDb         = org.Mm.eg.db, 
  keyType       = "ENTREZID", 
  ont           = "BP",    # Biological Process (use "MF" or "CC" for other categories)
  pAdjustMethod = "BH", 
  pvalueCutoff  = 0.05, 
  qvalueCutoff  = 0.2
)

ekegg <- enrichKEGG(
  gene          = gene, 
  universe      = universe,  # Custom background
  organism      = "mmu",  # Change for other species (e.g., "mmu" for mouse)
  pAdjustMethod = "BH", 
  pvalueCutoff  = 0.05
)

# View results
head(ekegg)


enrichdata<-enrichr(unique(c(differential_tao_exons_4d$GENE,differential_tao_introns_4d$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))

```

### GO Biological Process

```{r pladb bioprocess, fig.width=10, fig.height=8}

results <- enrichdata[[1]] %>%
  mutate(
    log_pval = -log10(P.value),  # Convert p-value
    Overlap = as.numeric(str_extract(Overlap, "^\\d+")),  # Extract first number
    Term = factor(Term, levels = rev(Term))  # Ensure correct term order
  ) %>%
  filter(P.value<=0.05)%>%
  arrange(P.value) %>%  # Order by p-value (smallest first)
  slice_head(n = 20)  # Select top 20

# Step 3: Create Dot Plot
ggplot(results, aes(x = log_pval, y = Term, size = Overlap, color = P.value)) +
  geom_point(alpha = 0.85) +
  scale_color_gradient(low = "blue", high = "red", trans = "reverse") +
  scale_size_continuous(range = c(4, 10)) +
  labs(x = "-log(p-value)", 
       y = "GO Terms", 
       color = "P-value", 
       size = "Gene Overlap") +
  theme_minimal(base_size = 14, base_family = "Helvetica") +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 12),
    panel.grid.major = element_line(color = "grey90"),
    panel.grid.minor = element_blank()
  )

```

### GO Cellular Component


```{r pladb cellcomponent, fig.width=10, fig.height=8}
results <- enrichdata[[2]] %>%
  mutate(
    log_pval = -log10(P.value),  # Convert p-value
    Overlap = as.numeric(str_extract(Overlap, "^\\d+")),  # Extract first number
    Term = factor(Term, levels = rev(Term))  # Ensure correct term order
  ) %>%
  filter(P.value<=0.05)%>%
  arrange(P.value) %>%  # Order by p-value (smallest first)
  slice_head(n = 20)  # Select top 20

# Step 3: Create Dot Plot
ggplot(results, aes(x = log_pval, y = Term, size = Overlap, color = P.value)) +
  geom_point(alpha = 0.85) +
  scale_color_gradient(low = "blue", high = "red", trans = "reverse") +
  scale_size_continuous(range = c(4, 10)) +
  labs(x = "-log(p-value)", 
       y = "GO Terms", 
       color = "P-value", 
       size = "Gene Overlap") +
  theme_minimal(base_size = 14, base_family = "Helvetica") +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 12),
    panel.grid.major = element_line(color = "grey90"),
    panel.grid.minor = element_blank()
  )

```


### GO Molecular Function

```{r pladb molfunction, fig.width=10, fig.height=8}
results <- enrichdata[[3]] %>%
  mutate(
    log_pval = -log10(P.value),  # Convert p-value
    Overlap = as.numeric(str_extract(Overlap, "^\\d+")),  # Extract first number
    Term = factor(Term, levels = rev(Term))  # Ensure correct term order
  ) %>%
  filter(P.value<=0.05)%>%
  arrange(P.value) %>%  # Order by p-value (smallest first)
  slice_head(n = 20)  # Select top 20

# Step 3: Create Dot Plot
ggplot(results, aes(x = log_pval, y = Term, size = Overlap, color = P.value)) +
  geom_point(alpha = 0.85) +
  scale_color_gradient(low = "blue", high = "red", trans = "reverse") +
  scale_size_continuous(range = c(4, 10)) +
  labs(x = "-log(p-value)", 
       y = "GO Terms", 
       color = "P-value", 
       size = "Gene Overlap") +
  theme_minimal(base_size = 14, base_family = "Helvetica") +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 12),
    panel.grid.major = element_line(color = "grey90"),
    panel.grid.minor = element_blank()
  )

```


```{r ENTREZ}
exon_go <- bitr(differential_tao_exons_4d$GENE, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
names(exon_go)<-c("GENE","ENTREZID")
differential_tao_exons_4d <- differential_tao_exons_4d %>%
  left_join(as.data.frame(exon_go), by = "GENE")

intron_go <- bitr(differential_tao_introns_4d$GENE, fromType = "ALIAS", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
names(intron_go)<-c("GENE","ENTREZID")
differential_tao_introns_4d <- differential_tao_introns_4d %>%
  left_join(as.data.frame(intron_go), by = "GENE")




```


## Speckle Gene Groups

```{r Wun et al. list of genes}
groupA_genelist <- read_excel("Table S1_GroupABC gene list.xlsx",
    sheet = "Group A", skip = 1)[,-1]$Geneid %>%
  lapply(function(x) gsub("\\.\\d+", "", x)) %>%
  unlist()

groupB_genelist <- read_excel("Table S1_GroupABC gene list.xlsx",
    sheet = "Group B")[,-1]$Geneid %>%
  lapply(function(x) gsub("\\.\\d+", "", x)) %>%
  unlist()

groupC_genelist <- read_excel("Table S1_GroupABC gene list.xlsx",
    sheet = "Group C")[,-1]$Geneid %>%
  lapply(function(x) gsub("\\.\\d+", "", x)) %>%
  unlist()



human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
attributes = c("ensembl_gene_id", "mmusculus_homolog_ensembl_gene", "mmusculus_homolog_perc_id_r1")
orth.mouse = getBM(attributes, values=TRUE, mart = human, uniqueRows=TRUE)

groupA_genelist_mouse <- orth.mouse[orth.mouse$ensembl_gene_id %in% groupA_genelist, "mmusculus_homolog_ensembl_gene"] %>%
  unlist()
groupB_genelist_mouse <- orth.mouse[orth.mouse$ensembl_gene_id %in% groupB_genelist, "mmusculus_homolog_ensembl_gene"] %>%
  unlist()
groupC_genelist_mouse <- orth.mouse[orth.mouse$ensembl_gene_id %in% groupC_genelist, "mmusculus_homolog_ensembl_gene"] %>%
  unlist()

groupA_genelist_mouse <- bitr(groupA_genelist_mouse, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
groupB_genelist_mouse <- bitr(groupB_genelist_mouse, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
groupC_genelist_mouse <- bitr(groupC_genelist_mouse, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)

# Exon list analysis
differential_tao_exons_4d$GroupA <- ifelse(differential_tao_exons_4d$ENTREZID %in% groupA_genelist_mouse$ENTREZID, TRUE, FALSE)

differential_tao_exons_4d$GroupB <- ifelse(differential_tao_exons_4d$ENTREZID %in% groupB_genelist_mouse$ENTREZID, TRUE, FALSE)

differential_tao_exons_4d$GroupC <- ifelse(differential_tao_exons_4d$ENTREZID %in% groupC_genelist_mouse$ENTREZID, TRUE, FALSE)

# Intron list analysis
differential_tao_introns_4d$GroupA <- ifelse(differential_tao_introns_4d$ENTREZID %in% groupA_genelist_mouse$ENTREZID, TRUE, FALSE)

differential_tao_introns_4d$GroupB <- ifelse(differential_tao_introns_4d$ENTREZID %in% groupB_genelist_mouse$ENTREZID, TRUE, FALSE)

differential_tao_introns_4d$GroupC <- ifelse(differential_tao_introns_4d$ENTREZID %in% groupC_genelist_mouse$ENTREZID, TRUE, FALSE)






splice_factors<-read_xlsx("SFs_list_ensembl_ID.xlsx")

differential_tao_exons_4d$splicing_factor<-tolower(differential_tao_exons_4d$GENE) %in% tolower(splice_factors$symbol)
differential_tao_introns_4d$splicing_factor<-tolower(differential_tao_introns_4d$GENE) %in% tolower(splice_factors$symbol)

speckle_protein<-read_tsv("nuclear_speckles_protein_human_atlas.tsv")

differential_tao_exons_4d$HPA_speckle_protein<-tolower(differential_tao_exons_4d$GENE) %in% tolower(speckle_protein$Gene)
differential_tao_introns_4d$HPA_speckle_protein<-tolower(differential_tao_introns_4d$GENE) %in% tolower(speckle_protein$Gene)

mouse_tf <- read_excel("mouse_tf.xlsx", 
    sheet = "TFs_Mouse")

differential_tao_exons_4d$transcription_factor<-tolower(differential_tao_exons_4d$GENE) %in% tolower(mouse_tf$`Gene Symbol`)
differential_tao_introns_4d$transcription_factor<-tolower(differential_tao_introns_4d$GENE) %in% tolower(mouse_tf$`Gene Symbol`)


speckle_introns_go <- enrichdata$GO_Biological_Process_2023[
  grepl("RNA|Cell Cycle|Translation", enrichdata$GO_Biological_Process_2023$Term, ignore.case = TRUE), 
]

# Extract and split the genes into a single vector
speckle_introns_go_genes <- unique(unlist(strsplit(speckle_introns_go$Genes, ";")))
differential_tao_exons_4d$intron_speckle_go<-tolower(differential_tao_exons_4d$GENE) %in% tolower(speckle_introns_go_genes)
differential_tao_introns_4d$intron_speckle_go<-tolower(differential_tao_introns_4d$GENE) %in% tolower(speckle_introns_go_genes)


```


# Rbfox2 Splicing Analysis

## Significant Events

```{r final arrange exons, warning=FALSE}
differential_tao_exons_4d <- differential_tao_exons_4d[!duplicated(differential_tao_exons_4d$EVENT), ] %>%
  arrange(desc(GroupB),desc(intron_speckle_go),desc(abs(deltapsi)),GroupC)


event_list_corr<-c(differential_tao_exons_4d$splicing_factor,differential_tao_introns_4d$splicing_factor)
correlation_matrix<-rbind(differential_tao_exons_4d[,-c(3:6,19:34)],differential_tao_introns_4d[,-c(3:6,19:34)])



correlation_matrix<-correlation_matrix[, c(colnames(correlation_matrix)[1:2], metadata_tao$run_accession)]
subset_genes <- correlation_matrix[event_list_corr, ]
rest_genes <- correlation_matrix[!event_list_corr, ]
subset_matrix <- as.matrix(subset_genes[, 3:14])
rest_matrix <- as.matrix(rest_genes[, 3:14])


results <- data.frame(
  Gene1 = character(),
  Gene2 = character(),
  Correlation = numeric(),
  P_value = numeric(),
  Adjusted_P_value = numeric(),
  stringsAsFactors = FALSE
)

# Compute correlations and p-values
significant_p_values <- c()
for (i in 1:nrow(subset_matrix)) {
  for (j in 1:nrow(rest_matrix)) {
    # Perform correlation test
    test <- cor.test(subset_matrix[i, ], rest_matrix[j, ], method = "pearson")
    
    # Store the raw p-values for later adjustment
    significant_p_values <- c(significant_p_values, test$p.value)
    
    # Temporarily store the results (to be adjusted later)
    results <- rbind(results, data.frame(
      Gene1 = subset_genes$GENE[i],
      Gene2 = rest_genes$GENE[j],
      Correlation = test$estimate,
      P_value = test$p.value,
      Adjusted_P_value = NA  # Placeholder for the adjusted p-value
    ))
  }
}

# Apply multiple testing correction (Benjamini-Hochberg)
adjusted_p_values <- p.adjust(significant_p_values, method = "BH")

# Update the results data frame with adjusted p-values
results$Adjusted_P_value <- adjusted_p_values

# Filter significant results (adjusted p-value < 0.05)
significant_results <- results[results$Adjusted_P_value < 0.01 & abs(results$Correlation) >=0.9, ]

# Plot heatmap
corr_plot<-ggplot(significant_results, aes(x = Gene1, y = Gene2, fill = Correlation)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 0,
    name = "Correlation"
  ) +
  labs(
    title = "Significant Correlations of Splicing",
    x = "Splicing Factors",
    y = "Splicing Events"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    axis.text.y = element_text(size = 0)
  ) 




# Assign numeric indices to non-splicing factor genes
gene2_index <- data.frame(Gene2 = unique(significant_results$Gene2))
gene2_index$Index <- 1:nrow(gene2_index)

# Merge with significant results
plot_data <- significant_results %>%
  left_join(gene2_index, by = "Gene2") %>%
  group_by(Gene1) %>%
  arrange(Index) %>%
  mutate(Cumulative_Count = row_number())

rbfox_genes<-unique(plot_data$Gene2[plot_data$Gene1=="Rbfox2"])

# Generate a sufficient number of colors
num_genes <- length(unique(plot_data$Gene1))
palette_colors <- colorRampPalette(RColorBrewer::brewer.pal(8, "Set2"))(num_genes) 

# Create the plot
corr_plot <- ggplot(plot_data, aes(x = Index, y = Cumulative_Count, group = Gene1, color = Gene1)) +
  geom_line(size = 2) +  # Thicker lines for visibility
  labs(
    title = "Cumulative Significant Interactions per Splicing Factor",
    x = "Significant Splicing Events in Myogenesis",
    y = "Cumulative Count of SFs Interactions"
  ) +
  theme_classic(base_size = 16) +  # Increase base size for readability
  theme(
    text = element_text(family = "Source Sans Pro"),  # Set font
    axis.title = element_text(size = 18, face = "bold"),  # Make axis titles more visible
    axis.text = element_text(size = 14),
    plot.title = element_text(size = 22, face = "bold", hjust = 0.5),
    legend.position = "none"  # Remove legend
  ) +
  scale_color_manual(values = palette_colors) +  # Dynamically apply colors
  geom_text_repel(data = plot_data %>% group_by(Gene1) %>% slice_tail(n = 1),
                  aes(label = Gene1), 
                  size = 5, hjust = -0.2, fontface = "bold") +
  annotate("text", x = max(plot_data$Index) * 0.1, y = max(plot_data$Cumulative_Count) * 0.9,
           label = "Interaction defined as:\nPearson index > 0.9\nFDR < 0.01",
           size = 7, hjust = 0, fontface = "italic", family = "Source Sans Pro")  

# Print the plot
print(corr_plot)
```




```{r plot splicing factors correlation}
# Subset the rows based on the selected events
subset_events <- correlation_matrix[event_list_corr, ]

# Extract the corresponding gene names for these events
gene_names <- subset_events$GENE

# Extract the numeric columns (expression values for events) - columns 3 to 14 in this example
subset_matrix <- as.matrix(subset_events[,-c(1:2)])
rownames(subset_matrix) <- subset_events$EVENT
# Compute the correlation matrix for the selected events (genes are rows)
cor_matrix <- cor(t(subset_matrix), method = "pearson", use = "complete.obs")

# Perform hierarchical clustering on the correlation matrix (both rows and columns)
distance_matrix <- dist(1 - cor_matrix)  # Compute distance as 1 - correlation
hc <- hclust(distance_matrix, method = "complete")  # Hierarchical clustering

# Reorder the correlation matrix based on the clustering result
ordered_cor_matrix <- cor_matrix[hc$order, hc$order]

# Convert the reordered correlation matrix into a long-format data frame for ggplot2
library(reshape2)
cor_df <- melt(ordered_cor_matrix)

# Create a data frame for event names with gene names appended
ordered_event_names <- rownames(ordered_cor_matrix)
ordered_event_labels <- paste(ordered_event_names, gene_names[hc$order], sep = " - ")

# Plot the clustered heatmap with gene names next to the event names
library(ggplot2)
ggplot(cor_df, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = "white") +  # Tiles with white borders
  scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 0,
    name = "Correlation"
  ) +
  labs(
    title = "Clustered Correlation Heatmap Among Selected Genes",
    x = "Genes",
    y = "Genes"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels
    axis.text.y = element_text(size = 10)  # Keep y-axis labels simple for now
  ) +
  scale_x_discrete(labels = ordered_event_labels) +  # Set x-axis labels to include gene names
  scale_y_discrete(labels = ordered_event_labels) +  # Set y-axis labels to include gene names
  geom_text(aes(label = round(value, 2)), size = 3, color = "black")  # Add correlation values



```




# Final Candidates List Sorted { .tabset}

These final lists show all the events found to be significant in all studies (in a pairwise comparison, myotubes vs myoblasts). Moreover, they are sorted by their average dPSI (the of dPSI across studies) an the average F statistic, and features such as the event length, splice scores, GC percent, whether it has an ontology related to Speckles (according to Apex2 and ARTR-seq papers) and if the gene containing the event appears in the gene lists (GroupA: permanently closed to speckles, groupB: transiently closed to speckles, GroupC: never closed to speckles) found by *Wu, J. et al. Dynamics of RNA localization to nuclear speckles are connected to splicing efficiency. Science Advances 10, eadp7727 (2024)*.






### Stats

```{r upset}
# https://www.cell.com/molecular-cell/fulltext/S1097-2765(21)01072-8?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS1097276521010728%3Fshowall%3Dtrue
# https://www.cell.com/cms/10.1016/j.molcel.2021.12.010/attachment/f3e6b74f-1196-43d1-be04-2aa3cc230713/mmc5.xlsx
speckles_molecularcell<-read_xlsx("apex2_seq_molecularcell.xlsx", sheet = "NuclearSpeckle")

# https://www.cell.com/molecular-cell/fulltext/S1097-2765(25)00143-1?rss=yes
speckles_nadiya_cell2025_hek<-read_xlsx("nadiya_khyzha_cell.xlsx", sheet = "HEK293T_SC35")
speckles_nadiya_cell2025_k562<-read_xlsx("nadiya_khyzha_cell.xlsx", sheet = "K562_SC35")

# -------------------------------
# 1. Combine Spire and FMN2 Events
# -------------------------------
spire_events <- unique(read.csv("spire_significant_events.csv")[, -1]$GENE)
fmn2_events <- unique(read.csv("fmn2_significant_events.csv")[, -1]$GENE)
spire_fmn2_events <- tolower(unique(c(fmn2_events, spire_events)))
# -------------------------------
# 2. Process Additional Gene Lists
# -------------------------------
# Speckle-associated genes based on dual index scores (> 0.8)
speckle_associated <- tolower(unique(c(speckles_molecularcell$`Table S4 - Related to Figure 2- Dual Index scores of transcripts identified with the markers belonging to each nuclear domain`[
  speckles_molecularcell$...2 > 0.8 & speckles_molecularcell$...3 > 0.8
], speckles_nadiya_cell2025_hek$gene_name[speckles_nadiya_cell2025_hek$diffexpressed=="UP"],speckles_nadiya_cell2025_k562$gene_name[speckles_nadiya_cell2025_k562$diffexpressed=="UP"])))

# Convert ENSEMBL IDs to gene symbols, ensuring uniqueness
groupA_genelist_mouse_symbol <- bitr(groupA_genelist_mouse$ENSEMBL, 
                                     fromType = "ENSEMBL", 
                                     toType = "SYMBOL", 
                                     OrgDb = org.Mm.eg.db) %>%
                                     distinct(SYMBOL, .keep_all = TRUE)

groupB_genelist_mouse_symbol <- bitr(groupB_genelist_mouse$ENSEMBL, 
                                     fromType = "ENSEMBL", 
                                     toType = "SYMBOL", 
                                     OrgDb = org.Mm.eg.db) %>%
                                     distinct(SYMBOL, .keep_all = TRUE)

# -------------------------------
# 3. Define Muscle Spliced Gene Sets
# -------------------------------
muscle_spliced_4d <- tolower(unique(c(differential_tao_exons_4d$GENE, 
                                      differential_tao_introns_4d$GENE)))
muscle_spliced_7d <- tolower(unique(c(differential_tao_exons$GENE, 
                                      differential_tao_introns$GENE)))

# Define the gene sets
genes_upset <- list(
  "Muscle Differentiation" = muscle_spliced_4d,
  Force_disrupted_genes = tolower(unique(c(spire_fmn2_events))),
  Associated_with_Speckles = tolower(unique(c(groupA_genelist_mouse_symbol$SYMBOL, 
                                              groupB_genelist_mouse_symbol$SYMBOL, speckle_associated)))
)

# Generate the Venn diagram
ggVennDiagram(genes_upset, label = "count") +  # Ensure only counts are shown
  scale_fill_gradient(low = "#6A5ACD", high = "#4682B4") +  # Shades of blue & purple
  scale_color_manual(values = c("#4B0082", "#4169E1", "#8A2BE2")) +  # Outline colors
  theme(plot.title = element_text(size = 16, face = "bold"),
        legend.position = "none")  # Hide legend if not needed


merged_myo_4d<-rbind(differential_tao_exons_4d,differential_tao_introns_4d)


all_layers<-filter(merged_myo_4d, tolower(GENE) %in% tolower(unique(c(groupA_genelist_mouse_symbol$SYMBOL, 
                                              groupB_genelist_mouse_symbol$SYMBOL, speckle_associated))) & tolower(GENE) %in% tolower(unique(c(molecularcell_speckles_nocodazole$Common_Gene[
      molecularcell_speckles_nocodazole$OMM_30m_p <= 0.05], spire_fmn2_events)))) %>%
  arrange(desc(abs(deltapsi)))

write.csv(all_layers, "final_all_layers.csv")

myo_forces_layers<-filter(merged_myo_4d, !tolower(GENE) %in% tolower(unique(c(groupA_genelist_mouse_symbol$SYMBOL, 
                                              groupB_genelist_mouse_symbol$SYMBOL, speckle_associated))) & tolower(GENE) %in% tolower(unique(c(molecularcell_speckles_nocodazole$Common_Gene[
      molecularcell_speckles_nocodazole$OMM_30m_p <= 0.05], spire_fmn2_events)))) %>%
  arrange(desc(abs(deltapsi)))

write.csv(myo_forces_layers, "final_myo_forces_layers.csv")

myo_associated_layers<-filter(merged_myo_4d, tolower(GENE) %in% tolower(unique(c(groupA_genelist_mouse_symbol$SYMBOL, 
                                              groupB_genelist_mouse_symbol$SYMBOL, speckle_associated))) & !tolower(GENE) %in% tolower(unique(c(molecularcell_speckles_nocodazole$Common_Gene[
      molecularcell_speckles_nocodazole$OMM_30m_p <= 0.05], spire_fmn2_events))))

write.csv(myo_associated_layers, "final_myo_associated_layers.csv")


only_myo_layers<-filter(merged_myo_4d, !tolower(GENE) %in% tolower(unique(c(groupA_genelist_mouse_symbol$SYMBOL, 
                                              groupB_genelist_mouse_symbol$SYMBOL, speckle_associated))) & !tolower(GENE) %in% tolower(unique(c(molecularcell_speckles_nocodazole$Common_Gene[
      molecularcell_speckles_nocodazole$OMM_30m_p <= 0.05], spire_fmn2_events)))) %>%
  arrange(desc(abs(deltapsi)))
write.csv(only_myo_layers, "final_only_myo_layers.csv")


```

```{r coplexity of apex2 genes assocaited with nucelar speckles}
# Load required packages
library(dplyr)
library(ggplot2)
library(forcats)
library(showtext)
library(ggpubr)

exons_per_gene_symbol<-exons_per_gene
ensembl <- useEnsembl(biomart = "genes", dataset = "mmusculus_gene_ensembl")

exons_per_gene_symbol$gene <- tolower(getBM(
    attributes = c("ensembl_gene_id", "external_gene_name"),
    filters = "ensembl_gene_id",
    values = exons_per_gene_symbol$gene,
    mart = ensembl
)$external_gene_name)

apex2_complexity<-exons_per_gene_symbol %>%
  filter(gene %in% speckle_associated)

apex2_complexity_neg<-exons_per_gene_symbol %>%
  filter(!gene %in% speckle_associated)


breaks <- c(0, 10, 50, Inf)
labels <- c("1-10", "11-50", ">50")

apex2_complexity$exon_bin <- cut(apex2_complexity$exons, breaks = breaks, labels = labels, right = TRUE)
apex2_complexity_neg$exon_bin <- cut(apex2_complexity_neg$exons, breaks = breaks, labels = labels, right = TRUE)



# 1. Add and enable Courier Prime from Google Fonts
font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()

# 2. Define your color palette (adjust names if needed)
palette <- c(
    `Negative control` = "#7f7f7f",  # bold blue
    `Nuclear Speckles` = "#1f77b4"   # vivid orange
)

# 3. Prepare your data
summ_neg <- prop.table(table(apex2_complexity_neg$exon_bin)) * 100
summ_pos <- prop.table(table(apex2_complexity$exon_bin))     * 100

df_plot <- bind_rows(
    tibble(exon_bin   = names(summ_neg),
           percentage = as.numeric(summ_neg),
           group      = "Negative control"),
    tibble(exon_bin   = names(summ_pos),
           percentage = as.numeric(summ_pos),
           group      = "Nuclear Speckles")
) %>%
    # ensure the negative control appears first in legend and bars
    mutate(exon_bin = fct_relevel(exon_bin, "1-10", "11-50", ">50"),
           group    = fct_relevel(group, "Negative control", "Nuclear Speckles"))

# 4. Plot with customized styling
ggplot(df_plot, aes(x = exon_bin, y = percentage, fill = group)) +
    
    # Bars
    geom_col(position = position_dodge(width = 0.75), width = 0.7, color = "black") +
    
    # Percentage labels
    geom_text(aes(label = sprintf("%.1f%%", percentage)),
              position = position_dodge(width = 0.75),
              vjust = -0.5,
              family = "Courier Prime",
              size = 3.5) +
    
    # Scale adjustments
    scale_y_continuous(expand = expansion(mult = c(0, 0.1)),
                       labels = scales::percent_format(scale = 1)) +
    scale_fill_manual(values = palette) +
    
    # Labels
    labs(
        x     = "Exon count bin",
        y     = "Percentage of genes",
        fill  = NULL,
        title = "Exon Count Complexity\nNuclear Speckle Genes vs. Negative Control"
    ) +
    
    # Theme: based on theme_pubclean + Courier Prime
    theme_pubclean(base_size = 14) +
    theme(
        text            = element_text(family = "Courier Prime"),
        plot.title      = element_text(face = "bold", size = 18, hjust = 0.5),
        axis.title      = element_text(face = "bold", size = 14),
        axis.text       = element_text(size = 12, color = "black"),
        axis.line       = element_line(size = 0.6),
        panel.background = element_rect(fill = "transparent", color = NA),
        plot.background  = element_rect(fill = "transparent", color = NA),
        panel.grid.major.y = element_line(color = "grey80", size = 0.3),
        panel.grid.minor.y = element_line(color = "grey90", size = 0.2),
        legend.position = "top",
        legend.text     = element_text(size = 12)
    ) +
    
    # Rename x-axis categories if desired
    scale_x_discrete(labels = c("1-10" = "1–10 exons",
                                "11-50" = "11–50 exons",
                                ">50"   = ">50 exons"))

```



## Enrichment Analysis with EnrichR of Candidate Genes { .tabset}


```{r pladb enrichr}
enrichdata<-enrichr(unique(final_good_list$GENE), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))

```

### GO Biological Process

```{r pladb bioprocess, fig.width=10, fig.height=8, warning=FALSE}

results <- enrichdata[[2]] %>%
  mutate(
    log_pval = -log10(P.value),  # Convert p-value
    Overlap = as.numeric(str_extract(Overlap, "^\\d+")),  # Extract first number
    Term = str_remove(Term, "\\s*\\(GO:\\d+\\)"),  # Remove GO ID in parentheses
    Term = factor(Term, levels = rev(Term))  # Ensure correct term order
  ) %>%
  filter(P.value <= 0.05) %>%
  arrange(P.value) %>%  # Order by p-value (smallest first)
  slice_head(n = 10)  # Select top 20


# Step 3: Create Dot Plot
p<-ggplot(results, aes(x = log_pval, y = Term, size = Overlap, color = P.value)) +
  geom_point(alpha = 0.85) +
  scale_color_gradient(low = "blue", high = "red", trans = "reverse") +
  scale_size_continuous(range = c(4, 10)) +
  labs(x = "-log(p-value)", 
       y= "",
       color = "P-value", 
       size = "Gene Overlap") +
  theme_minimal(base_size = 14, base_family = "Helvetica") +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    axis.text.y = element_text(face = "bold", color = "black", size = 12, margin = margin(r = 10)),
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 12),
    panel.grid.major = element_line(color = "grey90"),
    panel.grid.minor = element_blank()
  )

ggsave("final_go_BP.svg", plot = p, width = 12, height = 8)
p
```

### GO Cellular Component


```{r pladb cellcomponent, fig.width=10, fig.height=8, warning=FALSE}
results <- enrichdata[[2]] %>%
  mutate(
    log_pval = -log10(P.value),  # Convert p-value
    Overlap = as.numeric(str_extract(Overlap, "^\\d+")),  # Extract first number
    Term = factor(Term, levels = rev(Term))  # Ensure correct term order
  ) %>%
  filter(P.value<=0.05)%>%
  arrange(P.value) %>%  # Order by p-value (smallest first)
  slice_head(n = 20)  # Select top 20

# Step 3: Create Dot Plot
ggplot(results, aes(x = log_pval, y = Term, size = Overlap, color = P.value)) +
  geom_point(alpha = 0.85) +
  scale_color_gradient(low = "blue", high = "red", trans = "reverse") +
  scale_size_continuous(range = c(4, 10)) +
  labs(x = "-log(p-value)", 
       y = "GO Terms", 
       color = "P-value", 
       size = "Gene Overlap") +
  theme_minimal(base_size = 14, base_family = "Helvetica") +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 12),
    panel.grid.major = element_line(color = "grey90"),
    panel.grid.minor = element_blank()
  )

```


### GO Molecular Function

```{r pladb molfunction, fig.width=10, fig.height=8, warning=FALSE}
results <- enrichdata[[3]] %>%
  mutate(
    log_pval = -log10(P.value),  # Convert p-value
    Overlap = as.numeric(str_extract(Overlap, "^\\d+")),  # Extract first number
    Term = factor(Term, levels = rev(Term))  # Ensure correct term order
  ) %>%
  filter(P.value<=0.05)%>%
  arrange(P.value) %>%  # Order by p-value (smallest first)
  slice_head(n = 20)  # Select top 20

# Step 3: Create Dot Plot
ggplot(results, aes(x = log_pval, y = Term, size = Overlap, color = P.value)) +
  geom_point(alpha = 0.85) +
  scale_color_gradient(low = "blue", high = "red", trans = "reverse") +
  scale_size_continuous(range = c(4, 10)) +
  labs(x = "-log(p-value)", 
       y = "GO Terms", 
       color = "P-value", 
       size = "Gene Overlap") +
  theme_minimal(base_size = 14, base_family = "Helvetica") +
  theme(
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 12),
    panel.grid.major = element_line(color = "grey90"),
    panel.grid.minor = element_blank()
  )


# Extract all events
tao_all <- filterEvents(
  tao_events,
  types = c("C1", "C2", "C3", "S", "MIC", "IR"),
  N = 10
)

```


## Splicing Dynamics Heatmap of Final list

```{r heatmap prep, results='hide', fig.show='hide'}
set.seed(45)


# Convert PSI values to a matrix and set row names
tao_matrix <- tao_all$PSI[, 7:18] %>%
  as.matrix()
rownames(tao_matrix) <- tao_all$PSI$EVENT

# Filter rows based on the final event lists
filtered_events <- unique(c(filter(differential_tao_exons_4d, abs(deltapsi)>=0.10)$EVENT, filter(differential_tao_introns_4d, abs(deltapsi)>=0.10)$EVENT
))
tao_matrix <- tao_matrix[rownames(tao_matrix) %in% filtered_events, ]

# Arrange columns based on metadata
metadata_tao <- arrange(metadata_tao, experiment_title)
tao_matrix <- tao_matrix[, metadata_tao$run_accession]

# Create a dendrogram for the columns
col_dend <- hclust(dist(t(tao_matrix))) %>%
  as.dendrogram() %>%
  color_branches(k = 4) # Color branches with 4 clusters

# Check if row names contain "EX"
contains_EX <- grepl("EX", rownames(tao_matrix))

# Define an improved color gradient for the heatmap
col_fun <- colorRamp2(
  c(0, 50, 100),
  c("purple", "white", "orange")
)

number_splices<-3

reference_table<-data.frame(EVENT=c(differential_tao_exons_4d$EVENT,differential_tao_introns_4d$EVENT),GENE=c(differential_tao_exons_4d$GENE,differential_tao_introns_4d$GENE))


ht<-Heatmap(
  tao_matrix, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns  = col_dend,
  column_title = "Myoblast Samples at Different stages f development",
  row_title = "Splicing Events",
  column_names_rot = 45,
  column_labels = metadata_tao$experiment_title,
  column_dend_reorder = 1:12,
  row_km = number_splices,
  row_dend_reorder = F,
  rect_gp = gpar(col = "white", lwd = 0.3),
  column_names_gp = gpar(fontsize = 16),
  show_row_names = FALSE,

)
ht = draw(ht); clustered_events<-row_order(ht)
text_list<-list()
# Loop through clustered events and assign dynamic names
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(tao_matrix)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )

  # Assign the dynamic name and value
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}

protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t", 
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")

events_for_impact<-rownames(tao_matrix)

final_impact <- protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact)) %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))

# Remove non-annotated EVENTS from tao_matrix
tao_matrix <- tao_matrix[rownames(tao_matrix) %in% final_impact$EventID, ]

# Define the left annotation (points) with axis labels
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(2, "cm"),  # Adjusted width
    size = unit(2, "mm"),   # Adjusted size of points
    axis_param = list(
      side = "top",
      at = -2:2, # Numeric values to label
      labels = c(
        "Regulatory (5´UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45, # Rotation of labels
      gp = gpar(fontsize = 9) # Text style
    )
  )
)

# Define the right annotation (foo)
right_annotation <- rowAnnotation(
  foo = anno_empty(
    border = FALSE,
    width = max_text_width(unlist(text_list)) + unit(4, "mm")
  )
)
```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The impact of that Event at protein level is shown on the left.

```{r heatmap_plot, fig.width=30, fig.height=25, echo=TRUE, out.width="100%"}
library(ComplexHeatmap)
library(circlize)
library(viridis)
library(showtext)

# Add and activate Courier Prime font
font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()
showtext::showtext_opts(dpi=300)
set.seed(45)

col_fun <- colorRamp2(
  c(0, 50, 100),
  viridis(3)
)

ht <- Heatmap(
  tao_matrix,
  name = "PSI",
  col = col_fun,
  clustering_distance_rows = "pearson",
  cluster_columns = col_dend,
  column_title = "C2C12 Splicing in Differentiation",
  column_title_gp = gpar(fontsize = 24, fontface = "bold", fontfamily = "Courier Prime"),
  row_title = "Splicing Events with |ΔPSI|>=50%",
  row_title_gp = gpar(fontsize = 20, fontface = "italic", fontfamily = "Courier Prime"),
  column_labels = rep(c("D0","D2","D4","D7"), each=3),
  column_names_rot = 0,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", fontfamily = "Courier Prime"),
  column_dend_reorder = c(1:12),
  row_km = number_splices,
  column_gap = unit(4, "mm"),  # smaller gap between columns
  width = unit(24, "cm"),       # total width of heatmap smaller than default
  row_dend_reorder = FALSE,
  left_annotation = left_annotation,
  right_annotation = right_annotation,
  show_row_names = FALSE,
  rect_gp = gpar(col = "grey90", lwd = 0.5),
  row_gap = unit(4, "mm"),
  heatmap_legend_param = list(
    title = "PSI",
    col_fun = col_fun,
    title_gp = gpar(fontsize = 16, fontface = "bold", fontfamily = "Courier Prime"),
    labels_gp = gpar(fontsize = 12, fontfamily = "Courier Prime"),
    legend_direction = "vertical"
  )
)

# Draw to a file with specified size and dpi, using showtext for font rendering
png(
  filename = "Splicing_Dynamics_Heatmap_viridis.png",
  width = 18, height = 12, units = "in", res = 300, bg = "white"
)

draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")

for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(
      paste(text_list[[i]], collapse = "\n"), 
      x = unit(3, "mm"), just = "left", 
      gp = gpar(fontsize = 12, fontfamily = "Courier Prime")
    )
  })
}

dev.off()


draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")

for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(
      paste(text_list[[i]], collapse = "\n"), 
      x = unit(3, "mm"), just = "left", 
      gp = gpar(fontsize = 12, fontfamily = "Courier Prime")
    )
  })
}

```


### Table of Events from Heatmap

```{r, table heatmap final}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)

cluster_index <- rep(seq_along(row_order(ht)), lengths(row_order(ht)))


# Reorder the original matrix based on clustering
clustered_matrix <- tao_matrix[row_order, col_order]
final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```

```{r relation plot}
# Load necessary libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(rstatix)
library(ggpubr)

font_add_google(name = "Courier Prime", family = "Courier Prime")
showtext_auto()
showtext::showtext_opts(dpi=300)
# --- 1. Data Preparation ---
# (Assuming 'tao_matrix' and 'final_impact_string' already loaded)
original_columns <- colnames(tao_matrix)

tao_df <- as.data.frame(tao_matrix) %>%
  tibble::rownames_to_column("EVENT") %>%
  pivot_longer(cols = -EVENT, names_to = "sample", values_to = "value") %>%
  mutate(
    protein_impact = final_impact_string$ONTO[match(EVENT, final_impact_string$EventID)],
    protein_impact = case_when(
      grepl("ORF disruption upon sequence inclusion", protein_impact) ~ "ORF disrupted upon inclusion",
      grepl("ORF disruption upon sequence exclusion", protein_impact) ~ "ORF disrupted upon exclusion",
      grepl("Alternative", protein_impact) ~ "Alternative",
      grepl("In the CDS", protein_impact) ~ "CDS impacted",
      grepl("UTR", protein_impact) ~ "UTR",
      TRUE ~ NA_character_
    ),
    group_order = match(sample, original_columns),
    time = ceiling(group_order / 3),
    time = case_when(time == 4 ~ 7, TRUE ~ (time - 1) * 2)
  ) %>%
  filter(!is.na(protein_impact)) %>%
  mutate(protein_impact=factor(protein_impact, levels=c("Alternative", "CDS impacted", "UTR", "ORF disrupted upon exclusion", "ORF disrupted upon inclusion"))) %>%
  arrange(EVENT, sample, time) %>%
  select(-group_order)

# --- 2. Statistical Analysis ---
bootstrap_ci <- function(values, n_bootstrap = 1000, conf_level = 0.95) {
  boot <- replicate(n_bootstrap, mean(sample(values, replace = TRUE)))
  quantile(boot, probs = c((1 - conf_level)/2, 1 - (1 - conf_level)/2))
}

summary_df <- tao_df %>%
  group_by(time, protein_impact) %>%
  summarise(
    mean_value = mean(value),
    sd_value = sd(value),
    n = n(),
    ci_lower = bootstrap_ci(value)[1],
    ci_upper = bootstrap_ci(value)[2],
    .groups = 'drop'
  )

stat_test <- tao_df %>%
  group_by(protein_impact) %>%
  pairwise_t_test(value ~ time, paired = TRUE, p.adjust.method = 'fdr') %>%
  ungroup() %>%
  filter(p.adj < 0.05) %>%
  mutate(
    signif = case_when(
      p.adj < 0.001 ~ '***',
      p.adj < 0.01  ~ '**',
      TRUE           ~ '*'
    ),
    group1 = as.numeric(as.character(group1)),
    group2 = as.numeric(as.character(group2))
  ) %>%
  group_by(protein_impact) %>%
  mutate(
    max_mean = max(summary_df$mean_value[summary_df$protein_impact == protein_impact], na.rm = TRUE),
    # Increase spacing between bars:
    y.position = max_mean + (row_number() * 5)
  ) %>%
  ungroup()

# --- 3. Plotting ---
# Force y-axis from 0 to 100

po<-ggplot(summary_df, aes(x = time, y = mean_value, color = protein_impact, fill = protein_impact)) +
  # Raw points
  geom_point(data = tao_df, aes(x = time, y = value), color = 'grey70', alpha = 0.4, size = 1) +
  # Mean lines and points
  geom_line(size = 1.8) +
  geom_point(size = 3.2) +
  # Confidence ribbons
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.25, color = NA) +
  # Significance bars
  stat_pvalue_manual(
    stat_test,
    label = 'signif',
    xmin = 'group1',
    xmax = 'group2',
    y.position = 'y.position',
    tip.length = 0.02,
    size = 5,
    inherit.aes = FALSE
  ) +
  # Facets
  facet_wrap(~ protein_impact, ncol = 5) +
  # Axes
  scale_x_continuous(breaks = c(0, 2, 4, 7), labels = c('D0', 'D2', 'D4', 'D7'), expand = expansion(add = c(0.5, 0.5)))  +
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, by = 20), expand = expansion(mult = c(0, 0))) +
  # Color palette
  scale_color_brewer(type = 'qual', palette = 'Set2') +
  scale_fill_brewer(type = 'qual', palette = 'Set2') +
  # Theme
  theme_minimal(base_family = 'Courier Prime', base_size = 16) +
  theme(
    panel.grid.major = element_line(color = 'grey80', size = 0.4),
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = 'bold', size = 11, family = 'Courier Prime'),
    axis.title = element_text(face = 'bold', size = 20),
    axis.text = element_text(size = 16),
    legend.position = 'none',
    panel.spacing = unit(2, "lines")
  ) +
  labs(
    x = 'Time (days)',
    y = 'PSI',
    color = 'Protein Impact',
    fill = 'Protein Impact'
  )


# Save the plot as SVG
ggsave(
  filename = "ggpubr_plot.png",
  plot = po,
  device = "png",
  width = 16,
  height = 4,
  units = "in",
  dpi = 300
)

po
```

### Enrichment of ORF Disrupted Genes { .tabset}

Note that interpretation should be done taking into account whether that specific ORF-disrupting events is being spliced in or out. This just may give an idea of the ontology of disrupted proteins.

```{r orf enrichr}
enrichdata<-enrichr(unique(reference_table$GENE[reference_table$EVENT %in% final_impact$EventID[final_impact$ONTO %in% c(1,2)]]), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))


# Example structure: enrichData <- list(BP = df1, MF = df2, CC = df3)

combined_df <- bind_rows(
  lapply(names(enrichdata), function(category) {
    enrichdata[[category]] %>%
      mutate(Category = category)
  })
)

# Only keep significant terms
sig_terms <- combined_df %>%
  filter(Adjusted.P.value < 0.05)


# Clean category names to match colors
top_sig_terms <- sig_terms %>%
  group_by(Category) %>%
  top_n(-10, Adjusted.P.value) %>%
  ungroup() %>%
  mutate(Category = case_when(
    Category == "GO_Biological_Process_2023" ~ "BP",
    Category == "GO_Cellular_Component_2023" ~ "CC",
    Category == "GO_Molecular_Function_2023" ~ "MF",
    TRUE ~ Category
  ))

# Optional: clean term names
top_sig_terms$Term <- str_remove(top_sig_terms$Term, "\\ \\(.*\\)")

top_sig_terms$Count <- sapply(strsplit(as.character(top_sig_terms$Genes), ";"), length)



library(ggplot2)
library(forcats)
library(viridis)  # for viridis color scales

# Plot with modern color palette
ggplot(top_sig_terms, aes(x = -log10(Adjusted.P.value),
                          y = fct_reorder(Term, Adjusted.P.value),
                          size = Count,
                          color = -log10(Adjusted.P.value))) +
  geom_point(alpha = 0.8) +
  facet_wrap(~Category, scales = "free_y", ncol = 1) +
  scale_size_continuous(range = c(3, 8)) +
  scale_color_viridis(option = "plasma", direction = 1, 
                      name = "Adjusted P-value",
                      trans = "log10") +
  labs(
    x = expression(-log[10]~"(FDR)"),
    y = NULL,
    title = "ORF Disrupted GO"
  ) +
  theme_minimal(base_family = "Courier Prime") +
  theme(
    strip.text = element_text(size = 6, face = "bold"),
    axis.text.x  = element_text(size = 5),
    axis.text.y  = element_text(size = 4),
    legend.title = element_text(size = 6),
    legend.text = element_text(size = 6),
    plot.title = element_text(hjust = 0.5, size = 8)
  )


```

```{r srplot prep}
# if not already installed, install:
# install.packages(c("dplyr", "stringr"))
srplot<-enrichdata$GO_Molecular_Function_2023%>%
    filter(P.value < 0.05)

srplot$GeneRatio<-vapply(srplot$Overlap, function(x) {
    nums <- strsplit(x, "/")[[1]]
    as.numeric(nums[1]) / as.numeric(nums[2])
}, numeric(1))


library(dplyr)
library(stringr)

# assumereadxl# assume your input data.frame is called df
srplot <- srplot %>%
  # rename columns to match desired output
  rename(
    Description = Term,
    pvalue      = Adjusted.P.value
  ) %>%
  # convert semicolons to slashes for geneID, and count genes
  mutate(
    geneID = str_replace_all(Genes, ";", "/"),
    Count  = lengths(strsplit(Genes, ";"))
  ) %>%
  # select only the columns we want
  select(Description, GeneRatio, pvalue, geneID, Count)

# view result
write.table(
  srplot,
  file = "srplot.txt",
  sep = "\t",
  row.names = FALSE,
  col.names = TRUE,
  quote = FALSE
)
```


# Splicing Dynamics Heatmap of RBFOX2 correlated genes

```{r heatmap prep, results='hide', fig.show='hide'}
set.seed(45)



# Convert PSI values to a matrix and set row names
tao_matrix <- tao_all$PSI[, 7:18] %>%
  as.matrix()
rownames(tao_matrix) <- tao_all$PSI$EVENT

# Filter rows based on the final event lists
filtered_events <- unique(c(
  differential_tao_exons_4d$EVENT[differential_tao_exons_4d$GENE %in% rbfox_genes],
  differential_tao_introns_4d$EVENT[differential_tao_introns_4d$GENE %in% rbfox_genes]
))
tao_matrix <- tao_matrix[rownames(tao_matrix) %in% filtered_events, ]

# Arrange columns based on metadata
metadata_tao <- arrange(metadata_tao, experiment_title)
tao_matrix <- tao_matrix[, metadata_tao$run_accession]

# Create a dendrogram for the columns
col_dend <- hclust(dist(t(tao_matrix))) %>%
  as.dendrogram() %>%
  color_branches(k = 4) # Color branches with 4 clusters

# Check if row names contain "EX"
contains_EX <- grepl("EX", rownames(tao_matrix))

# Define an improved color gradient for the heatmap
col_fun <- colorRamp2(
  c(0, 50, 100),
  c("purple", "white", "orange")
)

number_splices<-8

reference_table<-data.frame(EVENT=c(differential_tao_exons_4d$EVENT,differential_tao_introns_4d$EVENT),GENE=c(differential_tao_exons_4d$GENE,differential_tao_introns_4d$GENE))


ht<-Heatmap(
  tao_matrix, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns  = col_dend,
  column_title = "Myoblast Samples at Different stages f development",
  row_title = "Splicing Events",
  column_names_rot = 45,
  column_labels = metadata_tao$experiment_title,
  column_dend_reorder = 1:12,
  row_km = number_splices,
  row_dend_reorder = F,
  rect_gp = gpar(col = "white", lwd = 0.3),
  column_names_gp = gpar(fontsize = 16),
  show_row_names = FALSE,

)
ht = draw(ht); clustered_events<-row_order(ht)
text_list<-list()
# Loop through clustered events and assign dynamic names
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(tao_matrix)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )

  # Assign the dynamic name and value
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    enrich_events$GO_Molecular_Function_2023$Term[1],
    enrich_events$GO_Molecular_Function_2023$Term[2],
    enrich_events$GO_Molecular_Function_2023$Term[3],
    sep = "; \n"
  )
}

protein_impact <- read.table("PROT_IMPACT-mm10-v2.3.tab", sep = "\t", 
                             header = TRUE, stringsAsFactors = FALSE, fill = TRUE, quote = "")

events_for_impact<-rownames(tao_matrix)

final_impact <- protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact)) %>%
  mutate(ONTO = ifelse(grepl("isoform", ONTO, ignore.case = TRUE), "-1", ONTO)) %>%
  mutate(ONTO = ifelse(grepl("UTR", ONTO, ignore.case = TRUE), "-2", ONTO)) %>%
  mutate(ONTO = case_when(
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("inclusion", ONTO, ignore.case = TRUE) ~ "2",
    grepl("ORF", ONTO, ignore.case = TRUE) & grepl("exclusion", ONTO, ignore.case = TRUE) ~ "1",
    TRUE ~ ONTO
  )) %>%
  mutate(ONTO = as.numeric(ONTO)) %>%
  replace_na(list(ONTO = 0))

# Remove non-annotated EVENTS from tao_matrix
tao_matrix <- tao_matrix[rownames(tao_matrix) %in% final_impact$EventID, ]

# Define the left annotation (points) with axis labels
left_annotation <- rowAnnotation(
  Impact = anno_points(
    final_impact$ONTO,
    width = unit(4, "cm"),  # Adjusted width
    size = unit(4, "mm"),   # Adjusted size of points
    axis_param = list(
      side = "top",
      at = -2:2, # Numeric values to label
      labels = c(
        "Regulatory (5´UTR)",
        "Alternative Isoform",
        "Unknown/NonCoding",
        "ORF disruption upon exclusion",
        "ORF disruption upon inclusion"
      ),
      labels_rot = 45, # Rotation of labels
      gp = gpar(fontsize = 15) # Text style
    )
  )
)

# Define the right annotation (foo)
right_annotation <- rowAnnotation(
  foo = anno_empty(
    border = FALSE,
    width = max_text_width(unlist(text_list)) + unit(4, "mm")
  )
)
```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* and *Molecular Function* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right. The impact of that Event at protein level is shown on the left.

```{r heatmap_plot, fig.width=30, fig.height=25, echo=TRUE, out.width="100%"}
set.seed(45)

ht <- Heatmap(
  tao_matrix, 
  name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns = col_dend,
  column_title = "C2C12 Samples at Different Stages of Development",
  column_title_gp = gpar(fontsize = 25, fontface = "bold"),
  row_title = "Splicing Events",
  row_title_gp = gpar(fontsize = 16, fontface = "italic"),
  column_names_rot = 45,
  column_dend_reorder = c(1:12),
  column_labels = metadata_tao$experiment_title,
  row_km = number_splices,
  left_annotation = left_annotation,   # Add the points on the left
  right_annotation = right_annotation, # Add foo on the right
  row_dend_reorder = F,
  column_names_gp = gpar(fontsize = 18, fontface = "bold", col = "darkblue"),
  show_row_names = FALSE,
  row_gap = unit(6, "mm"), # Adjust the gap size between rows
  column_gap = unit(4, "mm"), # Adjust the gap size between columns
  heatmap_legend_param = list(
    title = "PSI Value",
    title_gp = gpar(fontsize = 40),
    labels_gp = gpar(fontsize = 10),
    legend_position = c(-20, 0),  # Move the legend closer to the center (x, y coordinates)
    legend_direction = "vertical" # Align the legend horizontally
  )
)

# Draw the heatmap
ht <- draw(ht)

# Decorate the "foo" annotation slices (on the right)
for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left", gp = gpar(fontsize = 15))
  })
}
```

### Table of Events from Heatmap

```{r, table heatmap final}
row_order <- unlist(row_order(ht), use.names = F)
col_order <- unlist(column_order(ht), use.names = F)

cluster_index <- unlist(lapply(seq_along(row_order(ht)), function(i) rep(i, length(row_order(ht)[[i]]))))

# Reorder the original matrix based on clustering
clustered_matrix <- tao_matrix[row_order, col_order]
final_impact_string<-protein_impact %>%
  filter(EventID %in% events_for_impact) %>%
  arrange(match(EventID, events_for_impact))
final_impact_string<- final_impact_string[match(rownames(clustered_matrix),final_impact_string$EventID),]


heatmap_dataframe<-tibble(EVENT=rownames(clustered_matrix), heatmap_cluster=cluster_index, protein_impact=final_impact_string$ONTO)
heatmap_dataframe$GENE<-reference_table$GENE[match(heatmap_dataframe$EVENT, reference_table$EVENT)]
heatmap_dataframe<-select(heatmap_dataframe, GENE, EVENT, protein_impact, heatmap_cluster)

# Render DataTable with enhancements
datatable(
  heatmap_dataframe,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))


```

### Enrichment of ORF Disrupted Genes { .tabset}

Note that interpretation should be done taking into account whether that specific ORF-disrupting events is being spliced in or out. This just may give an idea of the ontology of disrupted proteins.

```{r orf enrichr}
enrichdata<-enrichr(unique(reference_table$GENE[reference_table$EVENT %in% final_impact$EventID[final_impact$ONTO %in% c(1,2)]]), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))

orf_comparingcontrol_events<-unique(reference_table$EVENT[reference_table$EVENT %in% final_impact$EventID[final_impact$ONTO %in% c(1,2)]])
```

#### GO Biological Process

```{r orf bioprocess fmndko, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[1]])
datatable(
  enrichdata[[1]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Cellular Component

```{r orf cellcomponent fmndko, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[2]])
datatable(
  enrichdata[[2]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

#### GO Molecular Function

```{r orf molfunction fmndko, fig.width=15, fig.height=8}
plotEnrich(enrichdata[[3]])
datatable(
  enrichdata[[3]],
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

# Rbfox2 correlated genes Dataframe { .tabset}

## Exons

```{r final df}


rbfox_exons<-read_excel("rbfox_exons.xls")
rbfox_events_pdac <- read_excel("rbfox_events_frompdac_good.xlsx")
differential_tao_exons_4d$rbfox<-tolower(differential_tao_exons_4d$GENE) %in% tolower(c(rbfox_events_pdac[[1]], rbfox_exons$`hg19.kgXref.
geneSymbol` ))

differential_tao_exons_4d$speckle_molecularcell<-tolower(differential_tao_exons_4d$GENE) %in% tolower(speckles_molecularcell$`Table S4 - Related to Figure 2- Dual Index scores of transcripts identified with the markers belonging to each nuclear domain`)


datatable(
  arrange(differential_tao_exons_4d[differential_tao_exons_4d$GENE %in% c("Rbfox2",rbfox_genes),], desc(speckle_molecularcell),desc(GroupA),desc(GroupB),desc(rbfox), desc(intron_speckle_go),desc(abs(deltapsi))),
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```

## Introns

```{r final df int}

differential_tao_introns_4d$rbfox<-tolower(differential_tao_introns_4d$GENE) %in% tolower(c(rbfox_events_pdac[[1]], rbfox_exons$`hg19.kgXref.
geneSymbol` ))

differential_tao_introns_4d$speckle_molecularcell<-tolower(differential_tao_introns_4d$GENE) %in% tolower(speckles_molecularcell$`Table S4 - Related to Figure 2- Dual Index scores of transcripts identified with the markers belonging to each nuclear domain`)


datatable(
  arrange(differential_tao_introns_4d[differential_tao_introns_4d$GENE %in% c("Rbfox2",rbfox_genes),], desc(speckle_molecularcell),desc(GroupA),desc(GroupB),desc(rbfox), desc(intron_speckle_go),desc(abs(deltapsi))),
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
))
```


# Event Densities 

```{r densities_per_event, warning=FALSE, message=FALSE, fig.width=16, fig.height=8}
event_names_exon <- c("MmuEX0028570", "MmuEX0028566", "MmuEX0028567", "MmuEX0019782", 
  "MmuEX0019783", "MmuINT1010600", "MmuEX0040282", "MmuEX1017973", 
  "MmuEX0039029", "MmuEX0039030", "MmuEX0039032", "MmuEX0012919", 
  "MmuEX0048979","MmuINT0112573","MmuINT1033613","MmuINT0095481")


# Generate individual plots and store them in a list
plots <- lapply(event_names_exon, function(eventID) {
  # Extract the corresponding gene name for the event
  geneName <- tao_events$PSI$GENE[match(eventID, tao_events$PSI$EVENT)]

  # Generate the plot
  tdensities <- plotIndividualDensitiesList(
    eventID = eventID,
    npoints = 500,
    psitable = tao_events$PSI,
    qualtable = tao_events$Qual,
    groupList = groupList_tao,
    maxDevTable = maxDevSimulationN100,
    seed = TRUE,
    CoverageWeight = FALSE
  )

  # Add titles and themes
  tdensities +
    theme_minimal(base_family = font) +
    theme(
      plot.title = element_text(size = 14, face = "bold"),  # Title size
      axis.text = element_text(size = 12),                # Axis label size
      axis.title = element_text(size = 14),               # Axis text size
      axis.text.y = element_blank(),                      # Remove Y-axis text
      axis.title.y = element_blank(),                     # Remove Y-axis title
      axis.ticks.y = element_blank()                      # Remove Y-axis tick
    ) +
    ggtitle(paste(geneName, eventID))
})

# Combine all plots with patchwork
final_plot_exons <- wrap_plots(plots, ncol = 4, byrow = TRUE) +
  plot_layout(guides = 'collect') +
  plot_annotation(
    caption = paste0("Created by AG on ", Sys.Date())
  )
# Display the combined plot
final_plot_exons
```



```{r SR motifs}

library(Biostrings)
included_exons_seq<-events_info %>%
  filter(EVENT %in% filter(differential_tao_exons_4d, deltapsi>0)$EVENT)


library(GenomicRanges)
library(BSgenome.Mmusculus.UCSC.mm10)
library(purrr)
library("data.table")  # if needed

# Parse coords using fast regex
parse_coords <- function(x) {
  stringi::stri_match_first_regex(x, "^(chr[^:]+):(\\d+)-(\\d+)")
}

parsed1 <- parse_coords(included_exons_seq$CO_C1)
parsed2 <- parse_coords(included_exons_seq$CO_A)

# Convert to data.table with parsed values
parsed_dt <- data.table::data.table(
  name     = included_exons_seq$EVENT,
  chr      = parsed1[, 2],  # same for both coords
  start1   = as.integer(parsed1[, 3]),
  end1     = as.integer(parsed1[, 4]),
  start2   = as.integer(parsed2[, 3]),
  end2     = as.integer(parsed2[, 4])
)

# Compute gap only if ranges do not overlap or touch
parsed_dt[, `:=`(
  gap_start = fifelse(end1 < start2, end1 + 1L,
                      fifelse(end2 < start1, end2 + 1L, NA_integer_)),
  gap_end   = fifelse(end1 < start2, start2 - 1L,
                      fifelse(end2 < start1, start1 - 1L, NA_integer_))
)]


# Filter valid gaps only (positive width)
parsed_dt <- parsed_dt[gap_start <= gap_end]

# Build GRanges object (with names!)
gap_gr <- GRanges(
  seqnames = parsed_dt$chr,
  ranges   = IRanges(start = parsed_dt$gap_start, end = parsed_dt$gap_end)
)
names(gap_gr) <- parsed_dt$name  # Set sequence names

# Extract sequences
seqs <- getSeq(BSgenome.Mmusculus.UCSC.mm10, gap_gr)

# Final result with names
result_5inc <- data.table(
  Exon_ID     = parsed_dt$name,
  chr      = as.character(seqnames(gap_gr)),
  start    = start(gap_gr),
  end      = end(gap_gr),
  width    = width(gap_gr),
  sequence = as.character(seqs)
) %>%
  mutate(status = "included")


# 3 prime included
parsed1 <- parse_coords(included_exons_seq$CO_A)
parsed2 <- parse_coords(included_exons_seq$CO_C2)

# Convert to data.table with parsed values
parsed_dt <- data.table::data.table(
  name     = included_exons_seq$EVENT,
  chr      = parsed1[, 2],  # same for both coords
  start1   = as.integer(parsed1[, 3]),
  end1     = as.integer(parsed1[, 4]),
  start2   = as.integer(parsed2[, 3]),
  end2     = as.integer(parsed2[, 4])
)

# Compute gap only if ranges do not overlap or touch
parsed_dt[, `:=`(
  gap_start = fifelse(end1 < start2, end1 + 1L,
                      fifelse(end2 < start1, end2 + 1L, NA_integer_)),
  gap_end   = fifelse(end1 < start2, start2 - 1L,
                      fifelse(end2 < start1, start1 - 1L, NA_integer_))
)]


# Filter valid gaps only (positive width)
parsed_dt <- parsed_dt[gap_start <= gap_end]

# Build GRanges object (with names!)
gap_gr <- GRanges(
  seqnames = parsed_dt$chr,
  ranges   = IRanges(start = parsed_dt$gap_start, end = parsed_dt$gap_end)
)
names(gap_gr) <- parsed_dt$name  # Set sequence names

# Extract sequences
seqs <- getSeq(BSgenome.Mmusculus.UCSC.mm10, gap_gr)

# Final result with names
result_3inc <- data.table(
  Exon_ID     = parsed_dt$name,
  chr      = as.character(seqnames(gap_gr)),
  start    = start(gap_gr),
  end      = end(gap_gr),
  width    = width(gap_gr),
  sequence = as.character(seqs)
) %>%
  mutate(status = "included")

skipped_exons_seq<-events_info %>%
  filter(EVENT %in% filter(differential_tao_exons_4d, deltapsi<0)$EVENT)

# 5 peimr skipped

parsed1 <- parse_coords(skipped_exons_seq$CO_C1)
parsed2 <- parse_coords(skipped_exons_seq$CO_A)

# Convert to data.table with parsed values
parsed_dt <- data.table::data.table(
  name     = skipped_exons_seq$EVENT,
  chr      = parsed1[, 2],  # same for both coords
  start1   = as.integer(parsed1[, 3]),
  end1     = as.integer(parsed1[, 4]),
  start2   = as.integer(parsed2[, 3]),
  end2     = as.integer(parsed2[, 4])
)

# Compute gap only if ranges do not overlap or touch
parsed_dt[, `:=`(
  gap_start = fifelse(end1 < start2, end1 + 1L,
                      fifelse(end2 < start1, end2 + 1L, NA_integer_)),
  gap_end   = fifelse(end1 < start2, start2 - 1L,
                      fifelse(end2 < start1, start1 - 1L, NA_integer_))
)]


# Filter valid gaps only (positive width)
parsed_dt <- parsed_dt[gap_start <= gap_end]

# Build GRanges object (with names!)
gap_gr <- GRanges(
  seqnames = parsed_dt$chr,
  ranges   = IRanges(start = parsed_dt$gap_start, end = parsed_dt$gap_end)
)
names(gap_gr) <- parsed_dt$name  # Set sequence names

# Extract sequences
seqs <- getSeq(BSgenome.Mmusculus.UCSC.mm10, gap_gr)

# Final result with names
result_5skip <- data.table(
  Exon_ID     = parsed_dt$name,
  chr      = as.character(seqnames(gap_gr)),
  start    = start(gap_gr),
  end      = end(gap_gr),
  width    = width(gap_gr),
  sequence = as.character(seqs)
) %>%
  mutate(status = "skipped")

# 3 prime skipped

parsed1 <- parse_coords(skipped_exons_seq$CO_A)
parsed2 <- parse_coords(skipped_exons_seq$CO_C2)

# Convert to data.table with parsed values
parsed_dt <- data.table::data.table(
  name     = skipped_exons_seq$EVENT,
  chr      = parsed1[, 2],  # same for both coords
  start1   = as.integer(parsed1[, 3]),
  end1     = as.integer(parsed1[, 4]),
  start2   = as.integer(parsed2[, 3]),
  end2     = as.integer(parsed2[, 4])
)

# Compute gap only if ranges do not overlap or touch
parsed_dt[, `:=`(
  gap_start = fifelse(end1 < start2, end1 + 1L,
                      fifelse(end2 < start1, end2 + 1L, NA_integer_)),
  gap_end   = fifelse(end1 < start2, start2 - 1L,
                      fifelse(end2 < start1, start1 - 1L, NA_integer_))
)]


# Filter valid gaps only (positive width)
parsed_dt <- parsed_dt[gap_start <= gap_end]

# Build GRanges object (with names!)
gap_gr <- GRanges(
  seqnames = parsed_dt$chr,
  ranges   = IRanges(start = parsed_dt$gap_start, end = parsed_dt$gap_end)
)
names(gap_gr) <- parsed_dt$name  # Set sequence names

# Extract sequences
seqs <- getSeq(BSgenome.Mmusculus.UCSC.mm10, gap_gr)

# Final result with names
result_3skip <- data.table(
  Exon_ID     = parsed_dt$name,
  chr      = as.character(seqnames(gap_gr)),
  start    = start(gap_gr),
  end      = end(gap_gr),
  width    = width(gap_gr),
  sequence = as.character(seqs)
) %>%
  mutate(status = "skipped")




# Convert to DNAStringSet
#xset <- DNAStringSet(included_exons_seq$Seq_A)
#names(xset) <- names(included_exons_seq$EVENT)

# Write to FASTA file
#writeXStringSet(xset, filepath = "included_exons.fa")


```

```{r parse rbpmap}
parse_rbpmap_to_df <- function(file_path) {
  lines <- readLines(file_path, warn = FALSE)
  
  exon_id <- NA
  protein <- NA
  results <- list()
  
  pattern_exon <- "^MmuEX\\d+"
  pattern_protein <- "^Protein: "
  pattern_data <- "^\\s*\\d+\\s+\\S+\\s+\\S+\\s+[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?\\s+[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$"
  
  for (line in lines) {
    line <- trimws(line)
    
    if (grepl(pattern_exon, line)) {
      exon_id <- line
    } else if (grepl(pattern_protein, line)) {
      protein <- sub("Protein: ", "", line)
    } else if (grepl(pattern_data, line)) {
      # Split by whitespace
      fields <- strsplit(line, "\\s+")[[1]]
      results[[length(results) + 1]] <- data.frame(
        Exon_ID = exon_id,
        Protein = protein,
        Sequence_Position = as.integer(fields[1]),
        Motif = fields[2],
        Kmer = fields[3],
        Z_score = as.numeric(fields[4]),
        P_value = as.numeric(fields[5]),
        stringsAsFactors = FALSE
      )
    }
  }
  
  # Combine all rows into one data.frame
  do.call(rbind, results)
}

# Example usage
rbpmap_5prime <- parse_rbpmap_to_df("5prime_included_exons.txt")
rbpmap_3prime <- parse_rbpmap_to_df("3prime_included_exons.txt")
rbpmap_exons <- parse_rbpmap_to_df("included_exons_rbpmap.txt")

```

```{r}
library(tidyverse)
library(patchwork)

all_seqs<-bind_rows(result_5inc, result_5skip)


rbpmap_5prime<-rbpmap_5prime %>%
  mutate(status="included")

rbpmap_5prime_skip<-rbpmap_5prime_skip %>%
  mutate(status="skipped")

rbpmap_all<-bind_rows(rbpmap_5prime,rbpmap_5prime_skip) %>%
  filter(P_value<0.05) %>%
  inner_join(select(all_seqs, Exon_ID, width )) 


# ── 3) Count motifs per gene/status
counts_df <- rbpmap_all %>%
  count(Exon_ID, status, width, name = "n_motifs") %>%
  mutate(norm_count=n_motifs/width)

# ── 4) Plot

# (a) Counts, colored by status
p_counts <- ggplot(counts_df, aes(x = status, 
                               y = n_motifs, fill = status)) +
  geom_boxplot()
```



```{r SR motifs skipped}

library(Biostrings)



library(GenomicRanges)
library(BSgenome.Mmusculus.UCSC.mm10)
library(purrr)
library("data.table")  # if needed



# Convert to DNAStringSet
xset <- DNAStringSet(skipped_exons_seq$Seq_A)
names(xset) <- names(skipped_exons_seq$EVENT)

# Write to FASTA file
writeXStringSet(xset, filepath = "skipped_exons.fa")


```

```{r parse rbpmap skipped}

# Example usage
rbpmap_5prime_skip <- parse_rbpmap_to_df("5prime_skipped_exons.txt")
rbpmap_3prime_skip <- parse_rbpmap_to_df("3prime_skipped_exons.txt")
rbpmap_exons_skip <- parse_rbpmap_to_df("rbpmap_skipped_exons.txt")

```


# System Settings

```{r session info}
sessionInfo()
```


