---
title: 'Force-based regulation of splicing during Myoblast differentiation'
subtitle: "Stage 1: Bioinformatical Analysis of Myogenic Transcripts"
author: "Andrés Gordo Ortiz @Al Jord Lab CRG"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    code_folding: hide
    code_download: false
    df_print: paged
    theme: flatly
    highlight: tango
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    number_sections: true

editor_options:
  markdown:
    wrap: 72


# Finally, you must have the Mus musculus (mm10 build) EVENT_INFO-mm10.tab and SPLICE_SITE_SCORES-mm10.tab files downloaded and unzipped in the root folder of this project repository. You can download them here:https://vastdb.crg.eu/wiki/Downloads
# The supplementary tables from Wu et al. 2024 are also needed in the root idirectory: https://www.science.org/doi/suppl/10.1126/sciadv.adp7727/suppl_file/sciadv.adp7727_tables_s1_to_s6.zip


header-includes:
  - '<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">'
  - '<style>
        #logos {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }
        #logos img {
            height: 80px;
            margin: 0 15px;
        }
     </style>'


---


```{css, echo=FALSE}
/* Custom CSS for styling */
body {
  font-family: 'Roboto', sans-serif; /* Body font */
  color: #333; /* Neutral dark gray for body text */
}

h1, h2, h3, h4, h5, h6 {
  font-family: 'Roboto', sans-serif; /* Headers font */
  font-weight: bold;
}

/* Header Colors */
h1 {
  font-size: 2.5em;
  color: #0099CD; /* Primary blue for main headers */
}

h2 {
  font-size: 2em;
  color: #0077A3; /* Slightly darker shade of blue for secondary headers */
}

h3 {
  font-size: 1.75em;
  color: #005F8C; /* Even darker blue for tertiary headers */
}

p {
  text-align: justify;
  line-height: 1.6; /* Improve readability */
}

/* Styling for subtitle, authors, and date */
.subtitle, .author, .date {
  color: #000; /* Black text */
  font-size: 1.25em; /* Slightly larger for emphasis */
  margin-bottom: 0.5em;
  text-align: center; /* Center alignment for clean layout */
}

/* Link styling */
a {
  color: #0099CD; /* Link color */
  text-decoration: none;
}

a:hover {
  color: #005F8C; /* Darker shade on hover */
  text-decoration: underline;
}

/* Table styling */
table {
  border-collapse: collapse;
  width: 100%;
}

table th, table td {
  border: 1px solid #ddd;
  padding: 10px;
}

table th {
  background-color: #0099CD; /* Header background blue */
  color: white; /* White text for contrast */
  text-align: center;
}

table tr:nth-child(even) {
  background-color: #f9f9f9; /* Light gray for even rows */
}

table tr:hover {
  background-color: #f1f1f1; /* Subtle highlight on hover */
}
```



```{r setup, include=FALSE}
# Ensure a clean environment and load required libraries.
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE
)


# Load required libraries
library("betAS")
library("ggplot2")
library("plotly")
library("dplyr")
library("tidyverse")
library("cowplot")
library("DT")
library("paletteer")
library("ggupset")
library("showtext")
library("ggtext")
library("readxl")
library("biomaRt")
library("patchwork")
library("org.Mm.eg.db")
library("org.Hs.eg.db")
library("enrichplot")
library("DOSE")
library("clusterProfiler")
library("ReactomePA")
library("ComplexHeatmap")
library("enrichR")
library("colorRamp2")
library("dendextend")
# Register Google fonts
showtext_auto()
font_add_google("Roboto", "roboto")
font="roboto"
```

# Introduction to this Analysis

## Objective

The primary aim is to identify a list of splicing events that meet the following criteria:
1. **Differential Splicing**: Events are differentially spliced during myoblast differentiation.
2. **Spatial Relevance**: Events occur near or around nuclear speckles.
This analysis is structured into two distinct parts, the first performed in the Bash Command     Line, and the second in R. This report shows the second part.

---

## Part 1: Upstream Analysis

The upstream analysis is performed on the CRG cluster using the Bash command line. This phase involves:

1. **Data Acquisition**:
   - Downloading `*.fastq.gz` files from five different databases.

2. **Alignment**:
   - Aligning the sequences to the latest mouse genome release (mm10) using **Bowtie2** through the [Vast-Tools align function](https://link.springer.com/protocol/10.1007/978-1-0716-2521-7_7).

3. **Event Detection**:
   - Importing inclusion tables generated by Vast-Tools into RStudio. The tables cover the following splicing events:
     - **Exons (EX)**
     - **Introns (IN)**
     - **Alternative 5' Splice Sites (Alt5)**
     - **Alternative 3' Splice Sites (Alt3)**
     - **Microexons (MIC)**

---

## Part 2: Statistical Analysis

### Objective
To identify splicing events that are differentially spliced during myoblast differentiation, and sorting them out according to how likely they are found close to nuclear speckles.

### Steps

1. **Statistical Testing**:
   - Use the [betAS package](https://rnajournal.cshlp.org/content/30/4/337) in R to perform:
     - **False Discovery Rate (FDR)**
     - **F-statistic**
     - **Probability of Differential Splicing (Pdiff)**

2. **Filtering Criteria**:
   - Retain events with:
     - **FDR ≤ 0.05**
     - **Pdiff ≥ 0.95**

3. **Batch Effect Mitigation**:
   - Each database is analyzed independently to control for batch effects and confounders.
   - A final list is generated by intersecting the splicing events identified in all five databases. This ensures the events are associated exclusively with differentiation. All exon related events (C1,C2,C3,S,including microexons) will be collapsed into a single list, EX. Alternative donor or acceptor sites are not taking into account for the list, as their junction will be harder to assess using RNA-FISH.

4. **Integration of Results**:
   - 10 lists (5 for exons and 5 for introns) are generated
   - Shared events across lists are conserved and ranked by:
     - **F-statistic**
     - **ΔPSI (Differential Percentage Spliced In)**

5. **Candidate Selection**:
   - Splicing events shared in all list are selected for the sorting stage.

6. **Feature Extraction**:
   - Features were obtained through the [VastDB](https://vastdb.crg.eu/) wiki:
     - **CG content**
     - **Sequence length**
     - **5'/3' splice site scores**
   - Gene Ontology related to Nuclear Speckles were obtained from [Wu et al. 2024](https://www.science.org/doi/10.1126/sciadv.adp7727) and [Baructu et al. 2022](https://www.cell.com/molecular-cell/fulltext/S1097-2765(21)01072-8):
     - **Speckles Gene Ontology**
     - **Gene List retained in Speckles**

The final plots showcase potentially promising events found in myoblast differentiation and related to speckles.

---

## Data Availability

| Name              | Publisher                             | ENA Link  | Year | Study Specs                                                                                                                                                                                           | Details                                                 |
|-------------------|---------------------------------------|-----------|------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------|
| Kuo Zhang         | Nature Communications                 | [SRP160431](https://www.ebi.ac.uk/ena/browser/view/SRP160431) | 2018 | Reads from knock-down and shControl cells in myoblast and myotube stages. Controls include 3 paired-end biological replicates each for myoblast and myotubes, totaling 12 fastq files.                | ~30M per biosample                                      |
| Lingjian Tao      | Molecular Biotechnology               | [SRP496253](https://www.ebi.ac.uk/ena/browser/view/SRP496253) | 2024 | Myotube formation observed after 4 days, full maturation at 7 days. 3 paired-end biological replicates per condition across 4 timepoints (0, 2, 4, 7 days), totaling 24 fastq files.                  | ~44M per biosample                                      |
| Pengcheng Lyu     | MDPI Cells (data quality verified)    | [SRP335878](https://www.ebi.ac.uk/ena/browser/view/SRP335878) | 2022 | C2C12 cells differentiated in media, with autophagy inhibition using chloroquine (10 µM or 20 µM). 2 paired-end biological replicates per condition for myoblast and myotube stages, 8 fastq files.   | ~45M per biosample                                      |
| Dominic W. Kolonay | Frontiers in Cell and Developmental Biology | [SRP471123](https://www.ebi.ac.uk/ena/browser/view/SRP471123) | 2024 | Myoblasts differentiated to myotubes in DMEM with horse serum and antibiotics over 5 days. 3 paired-end biological replicates per condition (0 days myoblast, 5 days myotube), totaling 12 fastq files. | ~90M per biosample in myotubes, ~140M per biosample in myoblasts |
| Christopher Azar  | Physiological Reports                 | [SRP198848](https://www.ebi.ac.uk/ena/browser/view/SRP198848) | 2021 | Cells differentiated for 6 days with daily media changes. 3 single-end biological replicates per condition (0 days myoblast, 6 days myotube), totaling 6 fastq files.                                 | ~30M per biosample

---

## Importing Inclusion Data

```{r inclusion tables}
# Zhang et al. 2018 data
zhang_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/Zhang_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")
zhang_events <- getEvents(zhang_data, tool = "vast-tools") # Extract alternative splicing events
zhang_events <- alternativeEvents(zhang_events, minPsi = 1, maxPsi = 99) # Filter events based on PSI thresholds
zhang_exons <- filterEvents(zhang_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 3)
zhang_introns <- filterEvents(zhang_events, types = c("IR"), N = 5)

# Lyu et al. 2022 data
lyu_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/Lyu_Cells_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")
lyu_events <- getEvents(lyu_data, tool = "vast-tools") # Extract alternative splicing events
lyu_events <- alternativeEvents(lyu_events, minPsi = 1, maxPsi = 99) # Filter events based on PSI thresholds
lyu_exons <- filterEvents(lyu_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 3)
lyu_introns <- filterEvents(lyu_events, types = c("IR"), N = 5)

# Tao et al. 2024 data
tao_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/Tao_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")
tao_events <- getEvents(tao_data, tool = "vast-tools") # Extract alternative splicing events
tao_events <- alternativeEvents(tao_events, minPsi = 1, maxPsi = 99) # Filter events based on PSI thresholds
tao_exons <- filterEvents(tao_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 3)
tao_introns <- filterEvents(tao_events, types = c("IR"), N = 5)

# Christopher Azar 2021 data
christopher_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/Christopher_Physioreports_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")
christopher_events <- getEvents(christopher_data, tool = "vast-tools") # Extract alternative splicing events
christopher_events <- alternativeEvents(christopher_events, minPsi = 1, maxPsi = 99) # Filter events based on PSI thresholds
christopher_exons <- filterEvents(christopher_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 3)
christopher_introns <- filterEvents(christopher_events, types = c("IR"), N = 5)


# Dominic Data
dominic_data <- getDataset(pathTables = paste0(getwd(),"/inclusion_tables/Dominic_Frontiers_INCLUSION_LEVELS_FULL-mm10.tab"), tool = "vast-tools")
dominic_events <- getEvents(dominic_data, tool = "vast-tools") # Extract alternative splicing events
dominic_events <- alternativeEvents(dominic_events, minPsi = 1, maxPsi = 99) # Filter events based on PSI thresholds
dominic_exons <- filterEvents(dominic_events, types = c("C1", "C2", "C3", "S", "MIC"), N = 3)
dominic_introns <- filterEvents(dominic_events, types = c("IR"), N = 5)
```


## Metadata { .tabset}

### Zhang

```{r metadata zhang}
# Load metadata file containing sample information
metadata_zhang <- read.csv(paste0(getwd(),"/metadata/zhangnature_metadata.csv"), sep = ",")
DT::datatable(metadata_zhang, options = list(pageLength = nrow(metadata_zhang), scrollX = TRUE))
```

### Lyu

```{r metadata lyu}
# Load metadata file containing sample information
metadata_lyu <- read.csv(paste0(getwd(),"/metadata/lyu_metadata.csv"), sep = ",")
DT::datatable(metadata_lyu, options = list(pageLength = nrow(metadata_lyu), scrollX = TRUE))
```
### Tao

```{r metadata tao}
# Load metadata file containing sample information
metadata_tao <- read.csv(paste0(getwd(),"/metadata/tao_metadata.csv"), sep = ",")
DT::datatable(metadata_tao, options = list(pageLength = nrow(metadata_tao), scrollX = TRUE))
```

### Christopher

```{r metadata christopher}
# Load metadata file containing sample information
metadata_christopher <- read.csv(paste0(getwd(),"/metadata/christopher_metadata.csv"), sep = ",")
DT::datatable(metadata_christopher, options = list(pageLength = nrow(metadata_christopher), scrollX = TRUE))
```

### Dominic

```{r metadata dominic}
# Load metadata file containing sample information
metadata_dominic <- read.csv(paste0(getwd(),"/metadata/dominic_metadata.csv"), sep = ",")
DT::datatable(metadata_dominic, options = list(pageLength = nrow(metadata_dominic), scrollX = TRUE))
```


---

# Splicing & Sample Quality Checking

Splicing inclusion plots look like a ***U*** when looking at the *exons*, as normally most of them are spliced out completely (dPSI=0) or constitutively spliced in (dPSI=100), but some of them are in between and those are the most interesting for the analysis. On the other hand, *introns* are ussually not included (that is their definiiton), but in a few cases they are included. Thus, the intron plot looks like the exponential distribution.

## PSI Distribution Plots { .tabset}

### Zhang

```{r psi distribution zhang}
# Create the first plot for exon inclusion levels
bigPicturePlotExons <- bigPicturePlot(table = zhang_exons$PSI)

# Customize the first plot for professional reporting
plot1 <- bigPicturePlotExons +
  ggtitle("Exon Inclusion Levels") +
  xlab("Samples") +
  ylab("PSI Values") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.background = element_rect(fill = "lightblue"),  # Set background color
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.25)
  )

# Create a second plot for a hypothetical dataframe
# Replace 'hypothetical_data$PSI' with your actual dataframe and column
bigPictureIntrons <- bigPicturePlot(table = zhang_introns$PSI)

# Customize the second plot
plot2 <- bigPictureIntrons +
  ggtitle("Introns Inclusion Levels") +
  xlab("Samples") +
  ylab("PSI Values") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.background = element_rect(fill = "lightblue"),  # Set background color
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.25)
  )

# Combine both plots into one figure using patchwork
plot1 / plot2
```

### Lyu

```{r lyu distribution plot}
# Create the first plot for exon inclusion levels
bigPicturePlotExons <- bigPicturePlot(table = lyu_exons$PSI)

# Customize the first plot for professional reporting
plot1 <- bigPicturePlotExons +
  ggtitle("Exon Inclusion Levels") +
  xlab("Samples") +
  ylab("PSI Values") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.background = element_rect(fill = "lightblue"),  # Set background color
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.25)
  )

# Create a second plot for a hypothetical dataframe
# Replace 'hypothetical_data$PSI' with your actual dataframe and column
bigPictureIntrons <- bigPicturePlot(table = lyu_introns$PSI)

# Customize the second plot
plot2 <- bigPictureIntrons +
  ggtitle("Introns Inclusion Levels") +
  xlab("Samples") +
  ylab("PSI Values") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.background = element_rect(fill = "lightblue"),  # Set background color
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.25)
  )

# Combine both plots into one figure using patchwork
plot1 / plot2
```

### Tao

```{r tao distri plots}
# Create the first plot for exon inclusion levels
bigPicturePlotExons <- bigPicturePlot(table = tao_exons$PSI)

# Customize the first plot for professional reporting
plot1 <- bigPicturePlotExons +
  ggtitle("Exon Inclusion Levels") +
  xlab("Samples") +
  ylab("PSI Values") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.background = element_rect(fill = "lightblue"),  # Set background color
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.25)
  )

# Create a second plot for a hypothetical dataframe
# Replace 'hypothetical_data$PSI' with your actual dataframe and column
bigPictureIntrons <- bigPicturePlot(table = tao_introns$PSI)

# Customize the second plot
plot2 <- bigPictureIntrons +
  ggtitle("Introns Inclusion Levels") +
  xlab("Samples") +
  ylab("PSI Values") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.background = element_rect(fill = "lightblue"),  # Set background color
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.25)
  )

# Combine both plots into one figure using patchwork
plot1 / plot2
```

### Christopher

```{r christopher distro plots}
# Create the first plot for exon inclusion levels
bigPicturePlotExons <- bigPicturePlot(table = christopher_exons$PSI)

# Customize the first plot for professional reporting
plot1 <- bigPicturePlotExons +
  ggtitle("Exon Inclusion Levels") +
  xlab("Samples") +
  ylab("PSI Values") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.25)
  )

# Create a second plot for a hypothetical dataframe
# Replace 'hypothetical_data$PSI' with your actual dataframe and column
bigPictureIntrons <- bigPicturePlot(table = christopher_introns$PSI)

# Customize the second plot
plot2 <- bigPictureIntrons +
  ggtitle("Introns Inclusion Levels") +
  xlab("Samples") +
  ylab("PSI Values") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.background = element_rect(fill = "lightblue"),  # Set background color
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.25)
  )

# Combine both plots into one figure using patchwork
plot1 / plot2
```

### Dominic


```{r dominic distro plots}
# Create the first plot for exon inclusion levels
bigPicturePlotExons <- bigPicturePlot(table = dominic_exons$PSI)

# Customize the first plot for professional reporting
plot1 <- bigPicturePlotExons +
  ggtitle("Exon Inclusion Levels") +
  xlab("Samples") +
  ylab("PSI Values") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.25)
  )

# Create a second plot for a hypothetical dataframe
# Replace 'hypothetical_data$PSI' with your actual dataframe and column
bigPictureIntrons <- bigPicturePlot(table = dominic_introns$PSI)

# Customize the second plot
plot2 <- bigPictureIntrons +
  ggtitle("Introns Inclusion Levels") +
  xlab("Samples") +
  ylab("PSI Values") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    panel.background = element_rect(fill = "lightblue"),  # Set background color
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.25)
  )

# Combine both plots into one figure using patchwork
plot1 / plot2
```

## PCA Plot

As it can be seen, most dataframe sinclude only two conditions; *Myoblasts* or *Myotubes*, where Tao has different time points. However, all of them are clustered properly in the PCA plot.


```{r pca calculation}
# Subset and scale data
pca_zhang <- zhang_data[, c("EVENT",zhang_events$Samples)]
pca_tao <- tao_data[,  c("EVENT",tao_events$Samples)]
pca_lyu <- lyu_data[,  c("EVENT",lyu_events$Samples)]
pca_christopher <- christopher_data[,  c("EVENT",christopher_events$Samples)]
pca_dominic <- dominic_data[,  c("EVENT",dominic_events$Samples)]

# merge pca data columns by row names
merged_pca <- pca_zhang %>%
  left_join(pca_tao, by = "EVENT") %>%
  left_join(pca_lyu, by = "EVENT") %>%
  left_join(pca_christopher, by="EVENT") %>%
  left_join(pca_dominic, by="EVENT") %>%
  na.omit()
rownames(merged_pca)<- merged_pca$EVENT
merged_pca<-t(merged_pca[,-1])

metadata_merged<-tibble(sample=c(metadata_zhang$run_accession,metadata_tao$run_accession,metadata_lyu$run_accession,metadata_christopher$run_accession,metadata_dominic$run_accession),experiment_title=c(metadata_zhang$experiment_title,metadata_tao$experiment_title,metadata_lyu$experiment_title,metadata_christopher$experiment_title,metadata_dominic$experiment_title))

# Reorder metadata_merged$experiment_title based on the row names of merged_pca
condition_pca <- metadata_merged$experiment_title[match(rownames(merged_pca), metadata_merged$sample)]


pca_result <- prcomp(merged_pca)  # Perform PCA

# Prepare PCA results for plotting
pca_data <- as.data.frame(pca_result$x)
pca_data$Sample <- rownames(pca_data)
pca_data$condition<-condition_pca
pca_data$data_origin<-c(rep("Zhang",ncol(pca_zhang)-1),rep("Tao",ncol(pca_tao)-1),rep("Lyu",ncol(pca_lyu)-1),rep("Christopher",ncol(pca_christopher)-1),rep("Dominic",ncol(pca_dominic)-1))
```

```{r pca plotting}
# Create PCA plot
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = as.factor(condition), shape = as.factor(data_origin))) +
  geom_point(size = 6) +
  labs(
    title = "<b style='font-size:18px;'>PCA of Samples (PSI Data)</b>",
    x = paste("PC1 (", round(100 * summary(pca_result)$importance[2, 1], 1), "%)", sep = ""),
    y = paste("PC2 (", round(100 * summary(pca_result)$importance[2, 2], 1), "%)", sep = ""),
    caption = paste0("Created by AG on ", Sys.Date()), size=3
  ) +
  theme_minimal(base_family = "roboto") +
  theme(
    plot.title = element_markdown(),
    plot.title.position = "plot",
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    legend.position = "right",
    legend.title = element_blank(),
    panel.background = element_rect(fill = "gray98"),
    panel.grid = element_line(color = "gray90", size = 0.5),
    panel.grid.major = element_line(color = "gray90", size = 0.5),
    panel.grid.minor = element_blank()
  ) +
  scale_colour_paletteer_d("MetBrewer::Hokusai3") +
  scale_colour_manual(values = rev(paletteer::paletteer_d("MetBrewer::Hokusai3")))
  coord_fixed()

pca_plot

```

## Total Splicing Events

As it can be observed below, the dominic dataset has the highest number of splicing events, what can be explained by the higher number of reads (90M in myotubes and 140M in myoblasts).


```{r splicing events barplot stacked}

# Adjusted version of the script
splicing_events <- tibble(
  event_type = names(zhang_events$EventsPerType),
  zhang = zhang_events$EventsPerType,
  tao = tao_events$EventsPerType,
  lyu = lyu_events$EventsPerType,
  christopher = christopher_events$EventsPerType,
  dominic = dominic_events$EventsPerType
)

splicing_events_long <- splicing_events %>%
  pivot_longer(cols = c(zhang, tao, lyu, christopher, dominic),
               names_to = "study", values_to = "count") %>%
  mutate(event_type = ifelse(event_type %in% c("C1", "C2", "C3", "ANN", "S", "MIC"), "EX", event_type)) %>%
  group_by(study, event_type) %>%
  summarize(count = sum(count, na.rm = TRUE), .groups = "drop")

# Proportion bar plot
plot_proportion <- ggplot(splicing_events_long, aes(fill = event_type, y = count, x = study)) +
  geom_bar(position = "fill", stat = "identity") +
  labs(
    title = "<b style='font-size:18px;'>Proportion of Splicing Events by Study</b>",
    x = NULL,
    y = "Proportion of Events",
    fill = "Event Type"
  ) +
  theme_minimal(base_family = font) +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    plot.title = element_markdown(),
    panel.background = element_rect(fill = "gray98"),
    panel.grid = element_line(color = "gray90", size = 0.5)
  ) +
  scale_fill_paletteer_d("MetBrewer::Hokusai3")

splicing_events_long_sum<-splicing_events_long %>%
  dplyr::group_by(study) %>%
  summarize(count = sum(count))


# Absolute counts plot
plot_absolute <- ggplot(splicing_events_long_sum, aes(y = count, x = study)) +
  geom_point(color = "#C70039", size = 3) +
  geom_text(aes(label = count), vjust = -1, size = 4, check_overlap = TRUE) +
  labs(
    x = "Study",
    y = "Number of Events",
    caption = paste0("Created by AG on ", Sys.Date()), size=3
  ) +
  theme_minimal(base_family = font) +
  theme(
    legend.position = "none",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text( size=15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3)
  ) +
  scale_y_continuous(expand = expansion(mult = c(0.1, 0.2)))


# Combine plots
combined_plot <- plot_proportion / plot_absolute +
  plot_layout(heights = c(1, 0.5)) &
  theme(plot.margin = margin(5,5, 0, 5))

# Display combined plot
combined_plot
```


# Differential Splicing Calculation

```{r aux_featuregroup}
# Extract unique groups and sample IDs
groupingVariable <- "experiment_title"
# Zhang
groups_zhang <- unique(metadata_zhang[, groupingVariable])
samples_zhang <- metadata_zhang$run_accession
# Tao
groups_tao <- unique(metadata_tao[, groupingVariable])
samples_tao <- metadata_tao$run_accession
# Lyu
groups_lyu <- unique(metadata_lyu[, groupingVariable])
samples_lyu <- metadata_lyu$run_accession
# Christopher
groups_christopher <- unique(metadata_christopher[, groupingVariable])
samples_christopher <- metadata_christopher$run_accession
# Dominic
groups_dominic <- unique(metadata_dominic[, groupingVariable])
samples_dominic <- metadata_dominic$run_accession


random_colors=c("#D8D97AFF", "#95C36EFF", "#74C8C3FF", "#5A97C1FF", "#295384FF", "#0A2E57FF")

# Create group list with metadata
groupList_zhang <- lapply(1:length(groups_zhang), function(i) {
  list(
    name = groups_zhang[i],
    samples = samples_zhang[metadata_zhang[, groupingVariable] == groups_zhang[i]],
    color = random_colors[i]
  )
})
names(groupList_zhang) <- groups_zhang

# Create group list with metadata for Tao, Christopher, and Lyu
groupList_tao <- lapply(1:length(groups_tao), function(i) {
  list(
    name = groups_tao[i],
    samples = samples_tao[metadata_tao[, groupingVariable] == groups_tao[i]],
    color = random_colors[i]
  )
})
names(groupList_tao) <- groups_tao

groupList_christopher <- lapply(1:length(groups_christopher), function(i) {
  list(
    name = groups_christopher[i],
    samples = samples_christopher[metadata_christopher[, groupingVariable] == groups_christopher[i]],
    color = random_colors[i]
  )
})
names(groupList_christopher) <- groups_christopher

groupList_lyu <- lapply(1:length(groups_lyu), function(i) {
  list(
    name = groups_lyu[i],
    samples = samples_lyu[metadata_lyu[, groupingVariable] == groups_lyu[i]],
    color = random_colors[i]
  )
})
names(groupList_lyu) <- groups_lyu

# Create group list with metadata
groupList_dominic <- lapply(1:length(groups_dominic), function(i) {
  list(
    name = groups_dominic[i],
    samples = samples_dominic[metadata_dominic[, groupingVariable] == groups_dominic[i]],
    color = random_colors[i]
  )
})
names(groupList_dominic) <- groups_dominic
```

```{r groups_auxiliary}
# Define groups
groupA    <- "Myoblasts"
groupB    <- "Myotubes"
groupA_tao<-"0_days"
groupB_tao<-"7_days"

# Define samples inside each group
# Zhang
samplesA_zhang    <- groupList_zhang[[groupA]]$samples
samplesB_zhang    <- groupList_zhang[[groupB]]$samples
colsGroupA_zhang    <- convertCols(zhang_exons$PSI, samplesA_zhang)
colsGroupB_zhang    <- convertCols(zhang_exons$PSI, samplesB_zhang)

# For Tao
samplesA_tao <- groupList_tao[[groupA_tao]]$samples
samplesB_tao <- groupList_tao[[groupB_tao]]$samples
colsGroupA_tao <- convertCols(tao_exons$PSI, samplesA_tao)
colsGroupB_tao <- convertCols(tao_exons$PSI, samplesB_tao)

# For Christopher
samplesA_christopher <- groupList_christopher[[groupA]]$samples
samplesB_christopher <- groupList_christopher[[groupB]]$samples
colsGroupA_christopher <- convertCols(christopher_exons$PSI, samplesA_christopher)
colsGroupB_christopher <- convertCols(christopher_exons$PSI, samplesB_christopher)

# For Lyu
samplesA_lyu <- groupList_lyu[[groupA]]$samples
samplesB_lyu <- groupList_lyu[[groupB]]$samples
colsGroupA_lyu <- convertCols(lyu_exons$PSI, samplesA_lyu)
colsGroupB_lyu <- convertCols(lyu_exons$PSI, samplesB_lyu)

# Dominic
samplesA_dominic    <- groupList_dominic[[groupA]]$samples
samplesB_dominic   <- groupList_dominic[[groupB]]$samples
colsGroupA_dominic   <- convertCols(dominic_exons$PSI, samplesA_dominic)
colsGroupB_dominic    <- convertCols(dominic_exons$PSI, samplesB_dominic)

set.seed(42) #Setting seed for downstream simulations of the beta distribution
```

## Exon Lists

### Calculations

```{r pdiff calculation}
# Preprae table for zhang
zhang_pdiff_exons <- prepareTableVolcano(
  psitable = zhang_exons$PSI,
  qualtable = zhang_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_zhang,
  colsB = colsGroupB_zhang,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed=TRUE,
  CoverageWeight = FALSE)

# Prepare table for Tao
tao_pdiff_exons <- prepareTableVolcano(
  psitable = tao_exons$PSI,
  qualtable = tao_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Christopher
christopher_pdiff_exons <- prepareTableVolcano(
  psitable = christopher_exons$PSI,
  qualtable = christopher_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_christopher,
  colsB = colsGroupB_christopher,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Lyu
lyu_pdiff_exons <- prepareTableVolcano(
  psitable = lyu_exons$PSI,
  qualtable = lyu_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_lyu,
  colsB = colsGroupB_lyu,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Preprae table for dominic
dominic_pdiff_exons <- prepareTableVolcano(
  psitable = dominic_exons$PSI,
  qualtable = dominic_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_dominic,
  colsB = colsGroupB_dominic,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed=TRUE,
  CoverageWeight = FALSE)
```

```{r f-stat}
# Preprae table for zhang
zhang_fstat_exons <- prepareTableVolcanoFstat(
  psitable = zhang_exons$PSI,
  qualtable = zhang_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_zhang,
  colsB = colsGroupB_zhang,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed=TRUE,
  CoverageWeight = FALSE)

# Prepare table for Tao
tao_fstat_exons <- prepareTableVolcanoFstat(
  psitable = tao_exons$PSI,
  qualtable = tao_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Christopher
christopher_fstat_exons <- prepareTableVolcanoFstat(
  psitable = christopher_exons$PSI,
  qualtable = christopher_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_christopher,
  colsB = colsGroupB_christopher,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Lyu
lyu_fstat_exons <- prepareTableVolcanoFstat(
  psitable = lyu_exons$PSI,
  qualtable = lyu_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_lyu,
  colsB = colsGroupB_lyu,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Preprae table for dominic
dominic_fstat_exons <- prepareTableVolcanoFstat(
  psitable = dominic_exons$PSI,
  qualtable = dominic_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_dominic,
  colsB = colsGroupB_dominic,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed=TRUE,
  CoverageWeight = FALSE)
```

```{r FDR calculations}
# Preprae table for zhang
zhang_fdr_exons <- prepareTableVolcanoFDR(
  psitable = zhang_exons$PSI,
  qualtable = zhang_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_zhang,
  colsB = colsGroupB_zhang,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 100,
  seed=TRUE,
  CoverageWeight = FALSE)

# Prepare table for Tao
tao_fdr_exons <- prepareTableVolcanoFDR(
  psitable = tao_exons$PSI,
  qualtable = tao_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Christopher
christopher_fdr_exons <- prepareTableVolcanoFDR(
  psitable = christopher_exons$PSI,
  qualtable = christopher_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_christopher,
  colsB = colsGroupB_christopher,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Lyu
lyu_fdr_exons <- prepareTableVolcanoFDR(
  psitable = lyu_exons$PSI,
  qualtable = lyu_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_lyu,
  colsB = colsGroupB_lyu,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Preprae table for dominic
dominic_fdr_exons <- prepareTableVolcanoFDR(
  psitable = dominic_exons$PSI,
  qualtable = dominic_exons$Qual,
  npoints = 500,
  colsA = colsGroupA_dominic,
  colsB = colsGroupB_dominic,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 100,
  seed=TRUE,
  CoverageWeight = FALSE)
```

```{r table_multgroups exons}
tao_anova_multgroups_exons <- prepareTableVolcanoMultipleGroups(psitable = tao_exons$PSI,
                                                 qualtable = tao_exons$Qual,
                                                 groupList = groupList_tao,
                                                 npoints = 500,
                                                 maxDevTable = maxDevSimulationN100, seed=TRUE, CoverageWeight = F)


```


### FDR Volcano Plots { .tabset}

#### Zhang

```{r zhang fdr volcano}
plotVolcanoFDR(betasTable =filter(zhang_fdr_exons,!is.na(EVENT)),
                            labA = groupA,
                            labB = groupB,
                            basalColor = "#89C0AE",
                            interestColor = "#E69A9C") +

theme(
  plot.title = element_text(size = 10),  # Title font size
  axis.title = element_text(size = 10),  # Axis title font size
  axis.text = element_text(size = 10),   # Axis text font size
  legend.text = element_text(size = 10), # Legend text font size
  legend.title = element_text(size = 10) # Legend title font size
)
```

#### Lyu

```{r lyu fdr volcano}
plotVolcanoFDR(betasTable =filter(lyu_fdr_exons,!is.na(EVENT)),
                            labA = groupA,
                            labB = groupB,
                            basalColor = "#89C0AE",
                            interestColor = "#E69A9C") +
theme(
  plot.title = element_text(size = 10),  # Title font size
  axis.title = element_text(size = 10),  # Axis title font size
  axis.text = element_text(size = 10),   # Axis text font size
  legend.text = element_text(size = 10), # Legend text font size
  legend.title = element_text(size = 10) # Legend title font size
)
```

#### Tao

```{r tao fdr volcano}
plotVolcanoFDR(betasTable =filter(tao_fdr_exons,!is.na(EVENT)),
                            labA = groupA_tao,
                            labB = groupB_tao,
                            basalColor = "#89C0AE",
                            interestColor = "#E69A9C") +
theme(
  plot.title = element_text(size = 10),  # Title font size
  axis.title = element_text(size = 10),  # Axis title font size
  axis.text = element_text(size = 10),   # Axis text font size
  legend.text = element_text(size = 10), # Legend text font size
  legend.title = element_text(size = 10) # Legend title font size
)
```

#### Christopher

```{r christopher fdr volcano}
plotVolcanoFDR(betasTable =filter(christopher_fdr_exons,!is.na(EVENT)),
                            labA = groupA,
                            labB = groupB,
                            basalColor = "#89C0AE",
                            interestColor = "#E69A9C") +
theme(
  plot.title = element_text(size = 10),  # Title font size
  axis.title = element_text(size = 20),  # Axis title font size
  axis.text = element_text(size = 20),   # Axis text font size
  legend.text = element_text(size = 20), # Legend text font size
  legend.title = element_text(size = 20) # Legend title font size
)
```

#### Dominic

```{r dominic fdr volcano}
plotVolcanoFDR(betasTable =filter(dominic_fdr_exons,!is.na(EVENT)),
                            labA = groupA,
                            labB = groupB,
                            basalColor = "#89C0AE",
                            interestColor = "#E69A9C") +
theme(
  plot.title = element_text(size = 10),  # Title font size
  axis.title = element_text(size = 10),  # Axis title font size
  axis.text = element_text(size = 10),   # Axis text font size
  legend.text = element_text(size = 10), # Legend text font size
  legend.title = element_text(size = 10) # Legend title font size
)
```

### Individual Combination Tables { .tabset}

#### Zhang

```{r zhang table making}
zhang_pdiff_exons_tab <- zhang_pdiff_exons[, c("GENE", "EVENT", "COORD", "Pdiff", "deltapsi")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.95) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(zhang_pdiff_exons_tab) <- 1:nrow(zhang_pdiff_exons_tab)

zhang_fstat_exons_tab <- zhang_fstat_exons[, c("GENE","EVENT","COORD","Fstat","deltapsi")] %>%
  filter(!is.na(EVENT)) %>%  # Remove rows where EVENT is NA
  arrange(desc(Fstat), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(zhang_fstat_exons_tab) <- 1:nrow(zhang_fstat_exons_tab)

zhang_fdr_exons_tab <- zhang_fdr_exons[, c("GENE","EVENT","COORD","FDR","deltapsi")] %>%
  filter(!is.na(EVENT), FDR<=0.05) %>%  # Remove rows where EVENT is NA
  arrange((FDR), desc(abs(deltapsi)))
rownames(zhang_fdr_exons_tab) <- 1:nrow(zhang_fdr_exons_tab)

# Find common EVENTs across all tables
common_events <- Reduce(intersect, list(zhang_pdiff_exons_tab$EVENT, zhang_fstat_exons_tab$EVENT, zhang_fdr_exons_tab$EVENT))

# Filter each table to include only rows with common EVENTs
filtered_exon_diff_tab <- zhang_pdiff_exons_tab %>% filter(EVENT %in% common_events)
filtered_exon_fstat_tab <- zhang_fstat_exons_tab %>% filter(EVENT %in% common_events)
filtered_exon_fdr_tab <- zhang_fdr_exons_tab %>% filter(EVENT %in% common_events)


# Select only unique columns from each table
filtered_exon_diff_tab <- filtered_exon_diff_tab %>% select(GENE,EVENT,COORD, deltapsi,Pdiff) # Extra column is Pdiff
filtered_exon_fstat_tab <- filtered_exon_fstat_tab %>% select(EVENT, Fstat) # Extra column is Fstat
filtered_exon_fdr_tab <- filtered_exon_fdr_tab %>% select(EVENT, FDR) # Extra column is FDR

# Merge the data frames by EVENT
zhang_exon_combination_tab <- filtered_exon_diff_tab %>%
  inner_join(filtered_exon_fstat_tab, by = "EVENT") %>%
  inner_join(filtered_exon_fdr_tab, by = "EVENT") %>%
  distinct() %>%
  arrange(desc(abs(deltapsi)), desc(Fstat),desc(FDR), desc(Pdiff))
```

```{r zhang combination table}
# Render DataTable with enhancements
datatable(
  zhang_exon_combination_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

output_dir <- file.path(getwd(), "results", "tables")
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
write.csv(zhang_exon_combination_tab,
          file = file.path(output_dir, paste0("zhang_exon_combination_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

#### Lyu

```{r lyu table making}
lyu_pdiff_exons_tab <- lyu_pdiff_exons[, c("GENE", "EVENT", "COORD", "Pdiff", "deltapsi")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.95) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(lyu_pdiff_exons_tab) <- 1:nrow(lyu_pdiff_exons_tab)

lyu_fstat_exons_tab <- lyu_fstat_exons[, c("GENE","EVENT","COORD","Fstat","deltapsi")] %>%
  filter(!is.na(EVENT)) %>%  # Remove rows where EVENT is NA
  arrange(desc(Fstat), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(lyu_fstat_exons_tab) <- 1:nrow(lyu_fstat_exons_tab)

lyu_fdr_exons_tab <- lyu_fdr_exons[, c("GENE","EVENT","COORD","FDR","deltapsi")] %>%
  filter(!is.na(EVENT), FDR<=0.05) %>%  # Remove rows where EVENT is NA
  arrange((FDR), desc(abs(deltapsi)))
rownames(lyu_fdr_exons_tab) <- 1:nrow(lyu_fdr_exons_tab)

# Find common EVENTs across all tables
common_events <- Reduce(intersect, list(lyu_pdiff_exons_tab$EVENT, lyu_fstat_exons_tab$EVENT, lyu_fdr_exons_tab$EVENT))

# Filter each table to include only rows with common EVENTs
filtered_exon_diff_tab <- lyu_pdiff_exons_tab %>% filter(EVENT %in% common_events)
filtered_exon_fstat_tab <- lyu_fstat_exons_tab %>% filter(EVENT %in% common_events)
filtered_exon_fdr_tab <- lyu_fdr_exons_tab %>% filter(EVENT %in% common_events)


# Select only unique columns from each table
filtered_exon_diff_tab <- filtered_exon_diff_tab %>% select(GENE,EVENT,COORD, deltapsi,Pdiff) # Extra column is Pdiff
filtered_exon_fstat_tab <- filtered_exon_fstat_tab %>% select(EVENT, Fstat) # Extra column is Fstat
filtered_exon_fdr_tab <- filtered_exon_fdr_tab %>% select(EVENT, FDR) # Extra column is FDR

# Merge the data frames by EVENT
lyu_exon_combination_tab <- filtered_exon_diff_tab %>%
  inner_join(filtered_exon_fstat_tab, by = "EVENT") %>%
  inner_join(filtered_exon_fdr_tab, by = "EVENT") %>%
  distinct() %>%
  arrange(desc(abs(deltapsi)), desc(Fstat),desc(FDR), desc(Pdiff))
```

```{r lyu combination table}
# Render DataTable with enhancements
datatable(
  lyu_exon_combination_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

write.csv(lyu_exon_combination_tab,
          file = file.path(output_dir, paste0("lyu_exon_combination_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

#### Tao

```{r tao table making}
tao_pdiff_exons_tab <- tao_pdiff_exons[, c("GENE", "EVENT", "COORD", "Pdiff", "deltapsi")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.95) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(tao_pdiff_exons_tab) <- 1:nrow(tao_pdiff_exons_tab)

tao_fstat_exons_tab <- tao_fstat_exons[, c("GENE","EVENT","COORD","Fstat","deltapsi")] %>%
  filter(!is.na(EVENT)) %>%  # Remove rows where EVENT is NA
  arrange(desc(Fstat), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(tao_fstat_exons_tab) <- 1:nrow(tao_fstat_exons_tab)

tao_fdr_exons_tab <- tao_fdr_exons[, c("GENE","EVENT","COORD","FDR","deltapsi")] %>%
  filter(!is.na(EVENT), FDR<=0.05) %>%  # Remove rows where EVENT is NA
  arrange((FDR), desc(abs(deltapsi)))
rownames(tao_fdr_exons_tab) <- 1:nrow(tao_fdr_exons_tab)

# Find common EVENTs across all tables
common_events <- Reduce(intersect, list(tao_pdiff_exons_tab$EVENT, tao_fstat_exons_tab$EVENT, tao_fdr_exons_tab$EVENT))

# Filter each table to include only rows with common EVENTs
filtered_exon_diff_tab <- tao_pdiff_exons_tab %>% filter(EVENT %in% common_events)
filtered_exon_fstat_tab <- tao_fstat_exons_tab %>% filter(EVENT %in% common_events)
filtered_exon_fdr_tab <- tao_fdr_exons_tab %>% filter(EVENT %in% common_events)


# Select only unique columns from each table
filtered_exon_diff_tab <- filtered_exon_diff_tab %>% select(GENE,EVENT,COORD, deltapsi,Pdiff) # Extra column is Pdiff
filtered_exon_fstat_tab <- filtered_exon_fstat_tab %>% select(EVENT, Fstat) # Extra column is Fstat
filtered_exon_fdr_tab <- filtered_exon_fdr_tab %>% select(EVENT, FDR) # Extra column is FDR

# Merge the data frames by EVENT
tao_exon_combination_tab <- filtered_exon_diff_tab %>%
  inner_join(filtered_exon_fstat_tab, by = "EVENT") %>%
  inner_join(filtered_exon_fdr_tab, by = "EVENT") %>%
  distinct() %>%
  arrange(desc(abs(deltapsi)), desc(Fstat),desc(FDR), desc(Pdiff))
```

```{r tao combination table}
# Render DataTable with enhancements
datatable(
  tao_exon_combination_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

write.csv(tao_exon_combination_tab,
          file = file.path(output_dir, paste0("tao_exon_combination_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

#### Dominic

```{r dominic table making}
dominic_pdiff_exons_tab <- dominic_pdiff_exons[, c("GENE", "EVENT", "COORD", "Pdiff", "deltapsi")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.95) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(dominic_pdiff_exons_tab) <- 1:nrow(dominic_pdiff_exons_tab)

dominic_fstat_exons_tab <- dominic_fstat_exons[, c("GENE","EVENT","COORD","Fstat","deltapsi")] %>%
  filter(!is.na(EVENT)) %>%  # Remove rows where EVENT is NA
  arrange(desc(Fstat), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(dominic_fstat_exons_tab) <- 1:nrow(dominic_fstat_exons_tab)

dominic_fdr_exons_tab <- dominic_fdr_exons[, c("GENE","EVENT","COORD","FDR","deltapsi")] %>%
  filter(!is.na(EVENT), FDR<=0.05) %>%  # Remove rows where EVENT is NA
  arrange((FDR), desc(abs(deltapsi)))
rownames(dominic_fdr_exons_tab) <- 1:nrow(dominic_fdr_exons_tab)

# Find common EVENTs across all tables
common_events <- Reduce(intersect, list(dominic_pdiff_exons_tab$EVENT, dominic_fstat_exons_tab$EVENT, dominic_fdr_exons_tab$EVENT))

# Filter each table to include only rows with common EVENTs
filtered_exon_diff_tab <- dominic_pdiff_exons_tab %>% filter(EVENT %in% common_events)
filtered_exon_fstat_tab <- dominic_fstat_exons_tab %>% filter(EVENT %in% common_events)
filtered_exon_fdr_tab <- dominic_fdr_exons_tab %>% filter(EVENT %in% common_events)


# Select only unique columns from each table
filtered_exon_diff_tab <- filtered_exon_diff_tab %>% select(GENE,EVENT,COORD, deltapsi,Pdiff) # Extra column is Pdiff
filtered_exon_fstat_tab <- filtered_exon_fstat_tab %>% select(EVENT, Fstat) # Extra column is Fstat
filtered_exon_fdr_tab <- filtered_exon_fdr_tab %>% select(EVENT, FDR) # Extra column is FDR

# Merge the data frames by EVENT
dominic_exon_combination_tab <- filtered_exon_diff_tab %>%
  inner_join(filtered_exon_fstat_tab, by = "EVENT") %>%
  inner_join(filtered_exon_fdr_tab, by = "EVENT") %>%
  distinct() %>%
  arrange(desc(abs(deltapsi)), desc(Fstat),desc(FDR), desc(Pdiff))
```

```{r dominic combination table}
# Render DataTable with enhancements
datatable(
  dominic_exon_combination_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


write.csv(dominic_exon_combination_tab,
          file = file.path(output_dir, paste0("dominic_exon_combination_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```


#### Christopher

```{r christopher table making}
christopher_pdiff_exons_tab <- christopher_pdiff_exons[, c("GENE", "EVENT", "COORD", "Pdiff", "deltapsi")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.95) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(christopher_pdiff_exons_tab) <- 1:nrow(christopher_pdiff_exons_tab)

christopher_fstat_exons_tab <- christopher_fstat_exons[, c("GENE","EVENT","COORD","Fstat","deltapsi")] %>%
  filter(!is.na(EVENT)) %>%  # Remove rows where EVENT is NA
  arrange(desc(Fstat), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(christopher_fstat_exons_tab) <- 1:nrow(christopher_fstat_exons_tab)

christopher_fdr_exons_tab <- christopher_fdr_exons[, c("GENE","EVENT","COORD","FDR","deltapsi")] %>%
  filter(!is.na(EVENT), FDR<=0.05) %>%  # Remove rows where EVENT is NA
  arrange((FDR), desc(abs(deltapsi)))
rownames(christopher_fdr_exons_tab) <- 1:nrow(christopher_fdr_exons_tab)

# Find common EVENTs across all tables
common_events <- Reduce(intersect, list(christopher_pdiff_exons_tab$EVENT, christopher_fstat_exons_tab$EVENT, christopher_fdr_exons_tab$EVENT))

# Filter each table to include only rows with common EVENTs
filtered_exon_diff_tab <- christopher_pdiff_exons_tab %>% filter(EVENT %in% common_events)
filtered_exon_fstat_tab <- christopher_fstat_exons_tab %>% filter(EVENT %in% common_events)
filtered_exon_fdr_tab <- christopher_fdr_exons_tab %>% filter(EVENT %in% common_events)


# Select only unique columns from each table
filtered_exon_diff_tab <- filtered_exon_diff_tab %>% select(GENE,EVENT,COORD, deltapsi,Pdiff) # Extra column is Pdiff
filtered_exon_fstat_tab <- filtered_exon_fstat_tab %>% select(EVENT, Fstat) # Extra column is Fstat
filtered_exon_fdr_tab <- filtered_exon_fdr_tab %>% select(EVENT, FDR) # Extra column is FDR

# Merge the data frames by EVENT
christopher_exon_combination_tab <- filtered_exon_diff_tab %>%
  inner_join(filtered_exon_fstat_tab, by = "EVENT") %>%
  inner_join(filtered_exon_fdr_tab, by = "EVENT") %>%
  distinct() %>%
  arrange(desc(abs(deltapsi)), desc(Fstat),desc(FDR), desc(Pdiff))
```

```{r christopher combination table}
# Render DataTable with enhancements
datatable(
  christopher_exon_combination_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

write.csv(christopher_exon_combination_tab,
          file = file.path(output_dir, paste0("christopher_exon_combination_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

#### ANOVA Multigroup

```{r anova exons making}
tao_anova_multgroups_exons_tab <- tao_anova_multgroups_exons[, c("GENE", "EVENT", "COORD", "Pdiff", "deltaAbsolute","Fstat","medianBetweens")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.95) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltaAbsolute)))  # Sort by Pdiff and abs(deltapsi)
rownames(tao_anova_multgroups_exons_tab) <- 1:nrow(tao_anova_multgroups_exons_tab)

# Render DataTable with enhancements
datatable(
  tao_anova_multgroups_exons_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltaAbsolute",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

write.csv(tao_anova_multgroups_exons_tab,
          file = file.path(output_dir, paste0("tao_anova_multgroups_exons_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

## Intron Lists

### Calculations

```{r pdiff intron calculation}
# Preprae table for zhang
zhang_pdiff_introns <- prepareTableVolcano(
  psitable = zhang_introns$PSI,
  qualtable = zhang_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_zhang,
  colsB = colsGroupB_zhang,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed=TRUE,
  CoverageWeight = FALSE)

# Prepare table for Tao
tao_pdiff_introns <- prepareTableVolcano(
  psitable = tao_introns$PSI,
  qualtable = tao_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Christopher
christopher_pdiff_introns <- prepareTableVolcano(
  psitable = christopher_introns$PSI,
  qualtable = christopher_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_christopher,
  colsB = colsGroupB_christopher,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Lyu
lyu_pdiff_introns <- prepareTableVolcano(
  psitable = lyu_introns$PSI,
  qualtable = lyu_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_lyu,
  colsB = colsGroupB_lyu,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Preprae table for dominic
dominic_pdiff_introns <- prepareTableVolcano(
  psitable = dominic_introns$PSI,
  qualtable = dominic_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_dominic,
  colsB = colsGroupB_dominic,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed=TRUE,
  CoverageWeight = FALSE)
```

```{r intron f-stat}
# Preprae table for zhang
zhang_fstat_introns <- prepareTableVolcanoFstat(
  psitable = zhang_introns$PSI,
  qualtable = zhang_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_zhang,
  colsB = colsGroupB_zhang,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed=TRUE,
  CoverageWeight = FALSE)

# Prepare table for Tao
tao_fstat_introns <- prepareTableVolcanoFstat(
  psitable = tao_introns$PSI,
  qualtable = tao_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Christopher
christopher_fstat_introns <- prepareTableVolcanoFstat(
  psitable = christopher_introns$PSI,
  qualtable = christopher_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_christopher,
  colsB = colsGroupB_christopher,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Lyu
lyu_fstat_introns <- prepareTableVolcanoFstat(
  psitable = lyu_introns$PSI,
  qualtable = lyu_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_lyu,
  colsB = colsGroupB_lyu,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Preprae table for dominic
dominic_fstat_introns <- prepareTableVolcanoFstat(
  psitable = dominic_introns$PSI,
  qualtable = dominic_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_dominic,
  colsB = colsGroupB_dominic,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  seed=TRUE,
  CoverageWeight = FALSE)
```

```{r FDR intron calculations}
# Preprae table for zhang
zhang_fdr_introns <- prepareTableVolcanoFDR(
  psitable = zhang_introns$PSI,
  qualtable = zhang_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_zhang,
  colsB = colsGroupB_zhang,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 100,
  seed=TRUE,
  CoverageWeight = FALSE)

# Prepare table for Tao
tao_fdr_introns <- prepareTableVolcanoFDR(
  psitable = tao_introns$PSI,
  qualtable = tao_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_tao,
  colsB = colsGroupB_tao,
  labA = groupA_tao,
  labB = groupB_tao,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Christopher
christopher_fdr_introns <- prepareTableVolcanoFDR(
  psitable = christopher_introns$PSI,
  qualtable = christopher_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_christopher,
  colsB = colsGroupB_christopher,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Prepare table for Lyu
lyu_fdr_introns <- prepareTableVolcanoFDR(
  psitable = lyu_introns$PSI,
  qualtable = lyu_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_lyu,
  colsB = colsGroupB_lyu,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 100,
  seed = TRUE,
  CoverageWeight = FALSE
)

# Preprae table for dominic
dominic_fdr_introns <- prepareTableVolcanoFDR(
  psitable = dominic_introns$PSI,
  qualtable = dominic_introns$Qual,
  npoints = 500,
  colsA = colsGroupA_dominic,
  colsB = colsGroupB_dominic,
  labA = groupA,
  labB = groupB,
  basalColor = "#89C0AE",
  interestColor = "#E69A9C",
  maxDevTable = maxDevSimulationN100,
  nsim = 100,
  seed=TRUE,
  CoverageWeight = FALSE)
```

```{r table_multgroups introns}
tao_anova_multgroups_introns <- prepareTableVolcanoMultipleGroups(psitable = tao_introns$PSI,
                                                 qualtable = tao_introns$Qual,
                                                 groupList = groupList_tao,
                                                 npoints = 500,
                                                 maxDevTable = maxDevSimulationN100, seed=TRUE, CoverageWeight = F)


```

```{r splicing distribution plot, fig.width=10}

# List of dataframes with metadata
dfs <- list(
  list(df = dominic_pdiff_exons, group = "Exons", study = "Dominic"),
  list(df = dominic_pdiff_introns, group = "Introns", study = "Dominic"),
  list(df = christopher_pdiff_exons, group = "Exons", study = "Christopher"),
  list(df = christopher_pdiff_introns, group = "Introns", study = "Christopher"),
  list(df = lyu_pdiff_exons, group = "Exons", study = "Lyu"),
  list(df = lyu_pdiff_introns, group = "Introns", study = "Lyu"),
  list(df = tao_pdiff_exons, group = "Exons", study = "Tao"),
  list(df = tao_pdiff_introns, group = "Introns", study = "Tao"),
  list(df = zhang_pdiff_exons, group = "Exons", study = "Zhang"),
  list(df = zhang_pdiff_introns, group = "Introns", study = "Zhang")
)

# Add metadata columns to each dataframe beforehand
dfs_with_metadata <- lapply(dfs, function(x) {
  x$df %>%
    mutate(Group = x$group, Study = x$study)
})

# Combine all dataframes into one using bind_rows() for faster merging
final_df <- bind_rows(dfs_with_metadata) %>%
  select(EVENT, Group, Study, deltapsi) %>%
  filter(abs(deltapsi)>=0.15) %>%
  na.omit()# Adjust this line if other columns should be prioritized


plot_psi_distribution <- ggplot(final_df, aes(x = deltapsi, fill = ifelse(deltapsi < 0, "Skipped", "Included"))) +
  geom_histogram(alpha = 0.8, bins = 100, position = "identity") +
  labs(
    title = "PSI Distribution",
    x = "ΔPSI (Myotubes-Myoblasts)",
    y = "Density",
    fill = "|ΔPSI| >= 0.15",
    caption = paste0("Created by AG on ", Sys.Date())
  ) +
  theme_minimal(base_family = font) +
  theme(
    legend.position = "right",
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(size = 15),
    panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(color = "gray80", size = 0.5),
    panel.grid.minor = element_line(color = "gray95", size = 0.3),
    strip.text = element_text(size = 14, face = "bold"),
    panel.spacing = unit(1.5, "lines")  # Increase the distance between facets
  ) +
  scale_fill_brewer(palette = "Set1") +
  facet_wrap(~Group)

plot_psi_distribution
```


### FDR Volcano Plots { .tabset}

#### Zhang

```{r zhang intron fdr volcano}
plotVolcanoFDR(betasTable =filter(zhang_fdr_introns,!is.na(EVENT)),
                            labA = groupA,
                            labB = groupB,
                            basalColor = "#89C0AE",
                            interestColor = "#E69A9C") +

theme(
  plot.title = element_text(size = 10),  # Title font size
  axis.title = element_text(size = 10),  # Axis title font size
  axis.text = element_text(size = 10),   # Axis text font size
  legend.text = element_text(size = 10), # Legend text font size
  legend.title = element_text(size = 10) # Legend title font size
)
```

#### Lyu

```{r lyu fdr intron volcano}
plotVolcanoFDR(betasTable =filter(lyu_fdr_introns,!is.na(EVENT)),
                            labA = groupA,
                            labB = groupB,
                            basalColor = "#89C0AE",
                            interestColor = "#E69A9C") +
theme(
  plot.title = element_text(size = 10),  # Title font size
  axis.title = element_text(size = 10),  # Axis title font size
  axis.text = element_text(size = 10),   # Axis text font size
  legend.text = element_text(size = 10), # Legend text font size
  legend.title = element_text(size = 10) # Legend title font size
)
```

#### Tao

```{r tao fdr intron volcano}
plotVolcanoFDR(betasTable =filter(tao_fdr_introns,!is.na(EVENT)),
                            labA = groupA_tao,
                            labB = groupB_tao,
                            basalColor = "#89C0AE",
                            interestColor = "#E69A9C") +
theme(
  plot.title = element_text(size = 10),  # Title font size
  axis.title = element_text(size = 10),  # Axis title font size
  axis.text = element_text(size = 10),   # Axis text font size
  legend.text = element_text(size = 10), # Legend text font size
  legend.title = element_text(size = 10) # Legend title font size
)
```

#### Christopher

```{r christopher fdr intron volcano}
plotVolcanoFDR(betasTable =filter(christopher_fdr_introns,!is.na(EVENT)),
                            labA = groupA,
                            labB = groupB,
                            basalColor = "#89C0AE",
                            interestColor = "#E69A9C") +
theme(
  plot.title = element_text(size = 10),  # Title font size
  axis.title = element_text(size = 10),  # Axis title font size
  axis.text = element_text(size = 10),   # Axis text font size
  legend.text = element_text(size = 10), # Legend text font size
  legend.title = element_text(size = 10) # Legend title font size
)
```

#### Dominic

```{r dominic fdr intron volcano}
plotVolcanoFDR(betasTable =filter(dominic_fdr_introns,!is.na(EVENT)),
                            labA = groupA,
                            labB = groupB,
                            basalColor = "#89C0AE",
                            interestColor = "#E69A9C") +
theme(
  plot.title = element_text(size = 10),  # Title font size
  axis.title = element_text(size = 10),  # Axis title font size
  axis.text = element_text(size = 10),   # Axis text font size
  legend.text = element_text(size = 10), # Legend text font size
  legend.title = element_text(size = 10) # Legend title font size
)
```

### Individual Combination Tables { .tabset}

#### Zhang

```{r zhang table intron making}
zhang_pdiff_introns_tab <- zhang_pdiff_introns[, c("GENE", "EVENT", "COORD", "Pdiff", "deltapsi")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.95) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(zhang_pdiff_introns_tab) <- 1:nrow(zhang_pdiff_introns_tab)

zhang_fstat_introns_tab <- zhang_fstat_introns[, c("GENE","EVENT","COORD","Fstat","deltapsi")] %>%
  filter(!is.na(EVENT)) %>%  # Remove rows where EVENT is NA
  arrange(desc(Fstat), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(zhang_fstat_introns_tab) <- 1:nrow(zhang_fstat_introns_tab)

zhang_fdr_introns_tab <- zhang_fdr_introns[, c("GENE","EVENT","COORD","FDR","deltapsi")] %>%
  filter(!is.na(EVENT), FDR<=0.05) %>%  # Remove rows where EVENT is NA
  arrange((FDR), desc(abs(deltapsi)))
rownames(zhang_fdr_introns_tab) <- 1:nrow(zhang_fdr_introns_tab)

# Find common EVENTs across all tables
common_events <- Reduce(intersect, list(zhang_pdiff_introns_tab$EVENT, zhang_fstat_introns_tab$EVENT, zhang_fdr_introns_tab$EVENT))

# Filter each table to include only rows with common EVENTs
filtered_intron_diff_tab <- zhang_pdiff_introns_tab %>% filter(EVENT %in% common_events)
filtered_intron_fstat_tab <- zhang_fstat_introns_tab %>% filter(EVENT %in% common_events)
filtered_intron_fdr_tab <- zhang_fdr_introns_tab %>% filter(EVENT %in% common_events)


# Select only unique columns from each table
filtered_intron_diff_tab <- filtered_intron_diff_tab %>% select(GENE,EVENT,COORD, deltapsi,Pdiff) # Extra column is Pdiff
filtered_intron_fstat_tab <- filtered_intron_fstat_tab %>% select(EVENT, Fstat) # Extra column is Fstat
filtered_intron_fdr_tab <- filtered_intron_fdr_tab %>% select(EVENT, FDR) # Extra column is FDR

# Merge the data frames by EVENT
zhang_intron_combination_tab <- filtered_intron_diff_tab %>%
  inner_join(filtered_intron_fstat_tab, by = "EVENT") %>%
  inner_join(filtered_intron_fdr_tab, by = "EVENT") %>%
  distinct() %>%
  arrange(desc(abs(deltapsi)), desc(Fstat),desc(FDR), desc(Pdiff))
```

```{r zhang combination intron table}
# Render DataTable with enhancements
datatable(
  zhang_intron_combination_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

output_dir <- file.path(getwd(), "results", "tables")
dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
write.csv(zhang_intron_combination_tab,
          file = file.path(output_dir, paste0("zhang_intron_combination_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

#### Lyu

```{r lyu table intron making}
lyu_pdiff_introns_tab <- lyu_pdiff_introns[, c("GENE", "EVENT", "COORD", "Pdiff", "deltapsi")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.95) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(lyu_pdiff_introns_tab) <- 1:nrow(lyu_pdiff_introns_tab)

lyu_fstat_introns_tab <- lyu_fstat_introns[, c("GENE","EVENT","COORD","Fstat","deltapsi")] %>%
  filter(!is.na(EVENT)) %>%  # Remove rows where EVENT is NA
  arrange(desc(Fstat), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(lyu_fstat_introns_tab) <- 1:nrow(lyu_fstat_introns_tab)

lyu_fdr_introns_tab <- lyu_fdr_introns[, c("GENE","EVENT","COORD","FDR","deltapsi")] %>%
  filter(!is.na(EVENT), FDR<=0.05) %>%  # Remove rows where EVENT is NA
  arrange((FDR), desc(abs(deltapsi)))
rownames(lyu_fdr_introns_tab) <- 1:nrow(lyu_fdr_introns_tab)

# Find common EVENTs across all tables
common_events <- Reduce(intersect, list(lyu_pdiff_introns_tab$EVENT, lyu_fstat_introns_tab$EVENT, lyu_fdr_introns_tab$EVENT))

# Filter each table to include only rows with common EVENTs
filtered_intron_diff_tab <- lyu_pdiff_introns_tab %>% filter(EVENT %in% common_events)
filtered_intron_fstat_tab <- lyu_fstat_introns_tab %>% filter(EVENT %in% common_events)
filtered_intron_fdr_tab <- lyu_fdr_introns_tab %>% filter(EVENT %in% common_events)


# Select only unique columns from each table
filtered_intron_diff_tab <- filtered_intron_diff_tab %>% select(GENE,EVENT,COORD, deltapsi,Pdiff) # Extra column is Pdiff
filtered_intron_fstat_tab <- filtered_intron_fstat_tab %>% select(EVENT, Fstat) # Extra column is Fstat
filtered_intron_fdr_tab <- filtered_intron_fdr_tab %>% select(EVENT, FDR) # Extra column is FDR

# Merge the data frames by EVENT
lyu_intron_combination_tab <- filtered_intron_diff_tab %>%
  inner_join(filtered_intron_fstat_tab, by = "EVENT") %>%
  inner_join(filtered_intron_fdr_tab, by = "EVENT") %>%
  distinct() %>%
  arrange(desc(abs(deltapsi)), desc(Fstat),desc(FDR), desc(Pdiff))
```

```{r lyu combination intron table}
# Render DataTable with enhancements
datatable(
  lyu_intron_combination_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

write.csv(lyu_intron_combination_tab,
          file = file.path(output_dir, paste0("lyu_intron_combination_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

#### Tao

```{r tao table intron making}
tao_pdiff_introns_tab <- tao_pdiff_introns[, c("GENE", "EVENT", "COORD", "Pdiff", "deltapsi")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.95) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(tao_pdiff_introns_tab) <- 1:nrow(tao_pdiff_introns_tab)

tao_fstat_introns_tab <- tao_fstat_introns[, c("GENE","EVENT","COORD","Fstat","deltapsi")] %>%
  filter(!is.na(EVENT)) %>%  # Remove rows where EVENT is NA
  arrange(desc(Fstat), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(tao_fstat_introns_tab) <- 1:nrow(tao_fstat_introns_tab)

tao_fdr_introns_tab <- tao_fdr_introns[, c("GENE","EVENT","COORD","FDR","deltapsi")] %>%
  filter(!is.na(EVENT), FDR<=0.05) %>%  # Remove rows where EVENT is NA
  arrange((FDR), desc(abs(deltapsi)))
rownames(tao_fdr_introns_tab) <- 1:nrow(tao_fdr_introns_tab)

# Find common EVENTs across all tables
common_events <- Reduce(intersect, list(tao_pdiff_introns_tab$EVENT, tao_fstat_introns_tab$EVENT, tao_fdr_introns_tab$EVENT))

# Filter each table to include only rows with common EVENTs
filtered_intron_diff_tab <- tao_pdiff_introns_tab %>% filter(EVENT %in% common_events)
filtered_intron_fstat_tab <- tao_fstat_introns_tab %>% filter(EVENT %in% common_events)
filtered_intron_fdr_tab <- tao_fdr_introns_tab %>% filter(EVENT %in% common_events)


# Select only unique columns from each table
filtered_intron_diff_tab <- filtered_intron_diff_tab %>% select(GENE,EVENT,COORD, deltapsi,Pdiff) # Extra column is Pdiff
filtered_intron_fstat_tab <- filtered_intron_fstat_tab %>% select(EVENT, Fstat) # Extra column is Fstat
filtered_intron_fdr_tab <- filtered_intron_fdr_tab %>% select(EVENT, FDR) # Extra column is FDR

# Merge the data frames by EVENT
tao_intron_combination_tab <- filtered_intron_diff_tab %>%
  inner_join(filtered_intron_fstat_tab, by = "EVENT") %>%
  inner_join(filtered_intron_fdr_tab, by = "EVENT") %>%
  distinct() %>%
  arrange(desc(abs(deltapsi)), desc(Fstat),desc(FDR), desc(Pdiff))
```

```{r tao combination intron table}
# Render DataTable with enhancements
datatable(
  tao_intron_combination_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

write.csv(tao_intron_combination_tab,
          file = file.path(output_dir, paste0("tao_intron_combination_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

#### Dominic

```{r dominic table intron making}
dominic_pdiff_introns_tab <- dominic_pdiff_introns[, c("GENE", "EVENT", "COORD", "Pdiff", "deltapsi")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.95) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(dominic_pdiff_introns_tab) <- 1:nrow(dominic_pdiff_introns_tab)

dominic_fstat_introns_tab <- dominic_fstat_introns[, c("GENE","EVENT","COORD","Fstat","deltapsi")] %>%
  filter(!is.na(EVENT)) %>%  # Remove rows where EVENT is NA
  arrange(desc(Fstat), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(dominic_fstat_introns_tab) <- 1:nrow(dominic_fstat_introns_tab)

dominic_fdr_introns_tab <- dominic_fdr_introns[, c("GENE","EVENT","COORD","FDR","deltapsi")] %>%
  filter(!is.na(EVENT), FDR<=0.05) %>%  # Remove rows where EVENT is NA
  arrange((FDR), desc(abs(deltapsi)))
rownames(dominic_fdr_introns_tab) <- 1:nrow(dominic_fdr_introns_tab)

# Find common EVENTs across all tables
common_events <- Reduce(intersect, list(dominic_pdiff_introns_tab$EVENT, dominic_fstat_introns_tab$EVENT, dominic_fdr_introns_tab$EVENT))

# Filter each table to include only rows with common EVENTs
filtered_intron_diff_tab <- dominic_pdiff_introns_tab %>% filter(EVENT %in% common_events)
filtered_intron_fstat_tab <- dominic_fstat_introns_tab %>% filter(EVENT %in% common_events)
filtered_intron_fdr_tab <- dominic_fdr_introns_tab %>% filter(EVENT %in% common_events)


# Select only unique columns from each table
filtered_intron_diff_tab <- filtered_intron_diff_tab %>% select(GENE,EVENT,COORD, deltapsi,Pdiff) # Extra column is Pdiff
filtered_intron_fstat_tab <- filtered_intron_fstat_tab %>% select(EVENT, Fstat) # Extra column is Fstat
filtered_intron_fdr_tab <- filtered_intron_fdr_tab %>% select(EVENT, FDR) # Extra column is FDR

# Merge the data frames by EVENT
dominic_intron_combination_tab <- filtered_intron_diff_tab %>%
  inner_join(filtered_intron_fstat_tab, by = "EVENT") %>%
  inner_join(filtered_intron_fdr_tab, by = "EVENT") %>%
  distinct() %>%
  arrange(desc(abs(deltapsi)), desc(Fstat),desc(FDR), desc(Pdiff))
```

```{r dominic combination intron table}
# Render DataTable with enhancements
datatable(
  dominic_intron_combination_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)


write.csv(dominic_intron_combination_tab,
          file = file.path(output_dir, paste0("dominic_intron_combination_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```


#### Christopher

```{r christopher table intron making}
christopher_pdiff_introns_tab <- christopher_pdiff_introns[, c("GENE", "EVENT", "COORD", "Pdiff", "deltapsi")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.95) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(christopher_pdiff_introns_tab) <- 1:nrow(christopher_pdiff_introns_tab)

christopher_fstat_introns_tab <- christopher_fstat_introns[, c("GENE","EVENT","COORD","Fstat","deltapsi")] %>%
  filter(!is.na(EVENT)) %>%  # Remove rows where EVENT is NA
  arrange(desc(Fstat), desc(abs(deltapsi)))  # Sort by Pdiff and abs(deltapsi)
rownames(christopher_fstat_introns_tab) <- 1:nrow(christopher_fstat_introns_tab)

christopher_fdr_introns_tab <- christopher_fdr_introns[, c("GENE","EVENT","COORD","FDR","deltapsi")] %>%
  filter(!is.na(EVENT), FDR<=0.05) %>%  # Remove rows where EVENT is NA
  arrange((FDR), desc(abs(deltapsi)))
rownames(christopher_fdr_introns_tab) <- 1:nrow(christopher_fdr_introns_tab)

# Find common EVENTs across all tables
common_events <- Reduce(intersect, list(christopher_pdiff_introns_tab$EVENT, christopher_fstat_introns_tab$EVENT, christopher_fdr_introns_tab$EVENT))

# Filter each table to include only rows with common EVENTs
filtered_intron_diff_tab <- christopher_pdiff_introns_tab %>% filter(EVENT %in% common_events)
filtered_intron_fstat_tab <- christopher_fstat_introns_tab %>% filter(EVENT %in% common_events)
filtered_intron_fdr_tab <- christopher_fdr_introns_tab %>% filter(EVENT %in% common_events)


# Select only unique columns from each table
filtered_intron_diff_tab <- filtered_intron_diff_tab %>% select(GENE,EVENT,COORD, deltapsi,Pdiff) # Extra column is Pdiff
filtered_intron_fstat_tab <- filtered_intron_fstat_tab %>% select(EVENT, Fstat) # Extra column is Fstat
filtered_intron_fdr_tab <- filtered_intron_fdr_tab %>% select(EVENT, FDR) # Extra column is FDR

# Merge the data frames by EVENT
christopher_intron_combination_tab <- filtered_intron_diff_tab %>%
  inner_join(filtered_intron_fstat_tab, by = "EVENT") %>%
  inner_join(filtered_intron_fdr_tab, by = "EVENT") %>%
  distinct() %>%
  arrange(desc(abs(deltapsi)), desc(Fstat),desc(FDR), desc(Pdiff))
```

```{r christopher combination intron table}
# Render DataTable with enhancements
datatable(
  christopher_intron_combination_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

write.csv(christopher_intron_combination_tab,
          file = file.path(output_dir, paste0("christopher_intron_combination_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

#### ANOVA Multigroup

```{r anova introns making}
tao_anova_multgroups_introns_tab <- tao_anova_multgroups_introns[, c("GENE", "EVENT", "COORD", "Pdiff", "deltaAbsolute","Fstat","medianBetweens")] %>%
  filter(!is.na(EVENT), Pdiff >= 0.90) %>%  # Remove rows where EVENT is NA and Pdiff >= 0.95
  arrange(desc(Pdiff), desc(abs(deltaAbsolute)))  # Sort by Pdiff and abs(deltapsi)
rownames(tao_anova_multgroups_introns_tab) <- 1:nrow(tao_anova_multgroups_introns_tab)

# Render DataTable with enhancements
datatable(
  tao_anova_multgroups_introns_tab,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "deltaAbsolute",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)

write.csv(tao_anova_multgroups_introns_tab,
          file = file.path(output_dir, paste0("tao_anova_multgroups_introns_table_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```



# Unsorted Intron Candidates List

```{r merging final intron lists intron, warning=FALSE}
# List of data frames to compare
dataframes <- list(
  christopher = christopher_intron_combination_tab,
  tao = tao_intron_combination_tab,
  lyu = lyu_intron_combination_tab,
  zhang= zhang_intron_combination_tab,
  dominic=dominic_intron_combination_tab
)

# Extract unique EVENTS for each data frame
events_list <- lapply(dataframes, function(df) unique(df$EVENT))

# Function to calculate unique and shared counts for a given combination of data frames
compute_shared_and_unique <- function(indices) {
  combo_names <- names(events_list)[indices]
  combined_events <- events_list[indices]

  # Compute shared and unique values
  shared <- Reduce(intersect, combined_events)
  unique_events <- lapply(combined_events, function(events) {
    setdiff(events, unlist(combined_events[-which(combined_events == events)]))
  })

  # Return result even if one combination is empty
  list(
    combination = combo_names, # Store as list of dataset names
    shared_count = length(shared),
    unique_counts = sapply(unique_events, length)
  )
}

# Iterate through all subsets of data frames
all_combinations <- lapply(1:length(events_list), function(k) {
  combn(seq_along(events_list), k, compute_shared_and_unique, simplify = FALSE)
})

# Flatten the list of results
all_combinations <- unlist(all_combinations, recursive = FALSE)

# Ensure all results have consistent structure
introns_candidates <- do.call(rbind, lapply(all_combinations, function(res) {
  # Handle cases with no unique values gracefully
  data.frame(
    Combination = I(list(res$combination)), # Store combination as list object
    Shared = res$shared_count,
    Unique = I(list(res$unique_counts)),   # Store unique counts as list object
    row.names = NULL
  )
}))
introns_candidates<-as.tibble(introns_candidates)

# Check if lengths match
if (length(introns_candidates$Combination) != length(introns_candidates$Shared)) {
  stop("Lengths of Combination and Shared are not the same.")
}

# Apply mutate safely
introns_candidates <- introns_candidates %>%
  mutate(Combination = map2(Combination, Shared, ~rep(list(.x), .y))) %>%
  unnest(Combination)


```


```{r plot venn diagram intron}
counts <- introns_candidates %>%
  count(Combination)

upset_intron_plot<-introns_candidates %>%
  ggplot(aes(x = Combination)) +
  geom_bar(fill = "#D8D97AFF", color = "black") +  # Polished bar colors
  geom_text(data = counts, aes(x = Combination, y = n, label = n),
            vjust = -0.5, size = 4) +  # Add count labels
  scale_x_upset(n_intersections = 31) +
  labs(
    title = paste("UpSet Plot of Intron Candidates (", Sys.Date(), ")", sep = ""),
    x = "Intron Combinations",
    y = "Count"
  ) +
  theme_minimal() +  # Professional font
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.major = element_line(color = "white", size = 0.7),
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "lightblue"),  # Set background color
    plot.background = element_rect(fill = "white"),
    strip.text = element_text(size = 12, face = "bold")
  )

upset_intron_plot
```

**Important**: Since merging all 5 dataframes result in only 5 candidates, I will merge only four (dominic, lyu, tao and christopher) to get a total of 15 candidates and gain statistical power.

```{r shared events final list intron}
dataframes <- list(
  christopher = christopher_intron_combination_tab,
  tao = tao_intron_combination_tab,
  lyu = lyu_intron_combination_tab,
  # zhang= zhang_intron_combination_tab, # In order to increase statistical power, I will remove the zhang dataframe in the merge, as this will< increase from 5 to 15 the number of candidates
  dominic=dominic_intron_combination_tab
)
# Extract the shared events in all dataframes
shared_events <- Reduce(intersect, lapply(dataframes, function(df) df$EVENT))

tao_shared<-tao_intron_combination_tab[tao_intron_combination_tab$EVENT %in% shared_events,]
lyu_shared<-lyu_intron_combination_tab[lyu_intron_combination_tab$EVENT %in% shared_events,]
zhang_shared<-zhang_intron_combination_tab[zhang_intron_combination_tab$EVENT %in% shared_events,]
christopher_shared<-christopher_intron_combination_tab[christopher_intron_combination_tab$EVENT %in% shared_events,]
dominic_shared<-dominic_intron_combination_tab[dominic_intron_combination_tab$EVENT %in% shared_events,]


combined_data <- bind_rows(
  tao_shared %>% mutate(Source = "tao_shared"),
  lyu_shared %>% mutate(Source = "lyu_shared"),
  # zhang_shared %>% mutate(Source = "zhang_shared"),
  christopher_shared %>% mutate(Source = "christopher_shared"),
  dominic_shared %>% mutate(Source = "dominic_shared")
)

# Calculate average per EVENT
averaged_data <- combined_data %>%
  group_by(EVENT) %>%
  summarise(
    avg_deltapsi = mean(deltapsi, na.rm = TRUE),
    avg_Fstat = mean(Fstat, na.rm = TRUE),
    avg_Pdiff = mean(Pdiff, na.rm = TRUE),
    avg_FDR = mean(FDR, na.rm = TRUE)
  )

final_intron_list<-averaged_data
final_intron_list$GENE <- tao_shared$GENE[match(final_intron_list$EVENT, tao_shared$EVENT)]
final_intron_list$COORD <- tao_shared$COORD[match(final_intron_list$EVENT, tao_shared$EVENT)]
final_intron_list<- final_intron_list %>%
  select(GENE, EVENT, COORD, everything()) %>%
  arrange(desc(abs(avg_deltapsi))) %>%
  mutate(avg_deltapsi = round(avg_deltapsi, 3),
         avg_Fstat = round(avg_Fstat, 3),
         avg_Pdiff = round(avg_Pdiff, 3),
         avg_FDR = round(avg_FDR, 3))

```

```{r output final list intron}
# Render DataTable with enhancements
datatable(
  final_intron_list,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "avg_Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "avg_deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)




write.csv(final_intron_list,
          file = file.path(output_dir, paste0("final_intron_list_unsorted_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```




# Unsorted Exon Candidates List

```{r merging final lists, warning=FALSE}
# List of data frames to compare
dataframes <- list(
  christopher = christopher_exon_combination_tab,
  tao = tao_exon_combination_tab,
  lyu = lyu_exon_combination_tab,
  zhang= zhang_exon_combination_tab,
  dominic=dominic_exon_combination_tab
)

# Extract unique EVENTS for each data frame
events_list <- lapply(dataframes, function(df) unique(df$EVENT))

# Function to calculate unique and shared counts for a given combination of data frames
compute_shared_and_unique <- function(indices) {
  combo_names <- names(events_list)[indices]
  combined_events <- events_list[indices]

  # Compute shared and unique values
  shared <- Reduce(intersect, combined_events)
  unique_events <- lapply(combined_events, function(events) {
    setdiff(events, unlist(combined_events[-which(combined_events == events)]))
  })

  # Return result even if one combination is empty
  list(
    combination = combo_names, # Store as list of dataset names
    shared_count = length(shared),
    unique_counts = sapply(unique_events, length)
  )
}

# Iterate through all subsets of data frames
all_combinations <- lapply(1:length(events_list), function(k) {
  combn(seq_along(events_list), k, compute_shared_and_unique, simplify = FALSE)
})

# Flatten the list of results
all_combinations <- unlist(all_combinations, recursive = FALSE)

# Ensure all results have consistent structure
exons_candidates <- do.call(rbind, lapply(all_combinations, function(res) {
  # Handle cases with no unique values gracefully
  data.frame(
    Combination = I(list(res$combination)), # Store combination as list object
    Shared = res$shared_count,
    Unique = I(list(res$unique_counts)),   # Store unique counts as list object
    row.names = NULL
  )
}))
exons_candidates<-as.tibble(exons_candidates)

# Check if lengths match
if (length(exons_candidates$Combination) != length(exons_candidates$Shared)) {
  stop("Lengths of Combination and Shared are not the same.")
}

# Apply mutate safely
exons_candidates <- exons_candidates %>%
  mutate(Combination = map2(Combination, Shared, ~rep(list(.x), .y))) %>%
  unnest(Combination)


```


```{r plot venn diagram}
counts <- exons_candidates %>%
  count(Combination)

upset_exon_plot<-exons_candidates %>%
  ggplot(aes(x = Combination)) +
  geom_bar(fill = "#D8D97AFF", color = "black") +  # Polished bar colors
  geom_text(data = counts, aes(x = Combination, y = n, label = n),
            vjust = -0.5, size = 4) +  # Add count labels
  scale_x_upset(n_intersections = 31) +
  labs(
    title = paste("UpSet Plot of Exon Candidates (", Sys.Date(), ")", sep = ""),
    x = "Exon Combinations",
    y = "Count"
  ) +
  theme_minimal() +  # Professional font
  theme(
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.major = element_line(color = "white", size = 0.7),
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "lightblue"),  # Set background color
    plot.background = element_rect(fill = "white"),
    strip.text = element_text(size = 12, face = "bold")
  )

upset_exon_plot
```

```{r shared events final list}
# Extract the shared events in all dataframes
shared_events <- Reduce(intersect, lapply(dataframes, function(df) df$EVENT))

tao_shared<-tao_exon_combination_tab[tao_exon_combination_tab$EVENT %in% shared_events,]
lyu_shared<-lyu_exon_combination_tab[lyu_exon_combination_tab$EVENT %in% shared_events,]
zhang_shared<-zhang_exon_combination_tab[zhang_exon_combination_tab$EVENT %in% shared_events,]
christopher_shared<-christopher_exon_combination_tab[christopher_exon_combination_tab$EVENT %in% shared_events,]
dominic_shared<-dominic_exon_combination_tab[dominic_exon_combination_tab$EVENT %in% shared_events,]


combined_data <- bind_rows(
  tao_shared %>% mutate(Source = "tao_shared"),
  lyu_shared %>% mutate(Source = "lyu_shared"),
  zhang_shared %>% mutate(Source = "zhang_shared"),
  christopher_shared %>% mutate(Source = "christopher_shared"),
    dominic_shared %>% mutate(Source = "dominic_shared")
)

# Calculate average per EVENT
averaged_data <- combined_data %>%
  group_by(EVENT) %>%
  summarise(
    avg_deltapsi = mean(deltapsi, na.rm = TRUE),
    avg_Fstat = mean(Fstat, na.rm = TRUE),
    avg_Pdiff = mean(Pdiff, na.rm = TRUE),
    avg_FDR = mean(FDR, na.rm = TRUE)
  )

final_exon_list<-averaged_data
final_exon_list$GENE <- tao_shared$GENE[match(final_exon_list$EVENT, tao_shared$EVENT)]
final_exon_list$COORD <- tao_shared$COORD[match(final_exon_list$EVENT, tao_shared$EVENT)]
final_exon_list<- final_exon_list %>%
  select(GENE, EVENT, COORD, everything()) %>%
  arrange(desc(abs(avg_deltapsi))) %>%
  mutate(avg_deltapsi = round(avg_deltapsi, 3),
         avg_Fstat = round(avg_Fstat, 3),
         avg_Pdiff = round(avg_Pdiff, 3),
         avg_FDR = round(avg_FDR, 3))

```

```{r output final list}
# Render DataTable with enhancements
datatable(
  final_exon_list,
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
) %>%
  formatStyle(
    columns = "avg_Pdiff",
    color = styleInterval(0.99, c("black", "green")),
    fontWeight = styleEqual(0.99, "bold")  # Ensure consistent styling
  ) %>%
  formatStyle(
  columns = "avg_deltapsi",
  color = styleInterval(c(-0.5, 0.5), c("black", "red", "black")),  # Three colors for two intervals
  fontWeight = styleInterval(c(-0.5, 0.5), c("normal", "bold", "normal"))  # Three weights for two intervals
)




write.csv(final_exon_list,
          file = file.path(output_dir, paste0("final_exon_list_unsorted_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

# Sorting Out according to features

```{r loading data from vastdb}
events_info<-read.table("EVENT_INFO-mm10.tab", header = TRUE, sep = "\t")
splice_scores<-read.table("SPLICE_SITE_SCORES-mm10.tab", header = FALSE, sep = "\t")
```

```{r gc content function}
calculate_GC_percent <- function(df, sequence_column) {
  # Ensure the specified column exists
  if (!sequence_column %in% colnames(df)) {
    stop("The specified column does not exist in the dataframe.")
  }

  # Function to calculate GC content for a single sequence
  gc_content <- function(sequence) {
    # Count G and C in the sequence
    gc_count <- sum(tolower(strsplit(sequence, NULL)[[1]]) %in% c('g', 'c'))
    # Calculate the GC percentage
    gc_percentage <- (gc_count / nchar(sequence)) * 100
    return(gc_percentage)
  }

  # Apply the GC content function to each row's sequence
  df$GC_percent <- sapply(df[[sequence_column]], gc_content)

  return(df)
}
```

```{r splice score site extraction function}
# Function to extract V3 values based on EVENT
extract_V3_for_event <- function(event_value, splice_scores) {
  # Filter rows where V1 matches the event_value
  filtered_rows <- splice_scores %>%
    filter(V1 == event_value)

  # Extract the V3 column and return as a list
  return(list(filtered_rows$V3))
}

```


```{r final list features extraction}
# Exon List features
final_exon_list$length<-events_info$LE_n[match(final_exon_list$EVENT, events_info$EVENT)]
final_exon_list$sequence<-events_info$Seq_A[match(final_exon_list$EVENT, events_info$EVENT)]

final_exon_list$splice_scores <- apply(final_exon_list, 1, function(row) {
  # Get the event value from the current row
  event_value <- row["EVENT"]

  # Call the function to extract the V3 values
  extract_V3_for_event(event_value, splice_scores)
})

# Unnest the list in V3_values into two separate columns
final_exon_list <- final_exon_list %>%
  unnest(cols = splice_scores) %>%
  separate(splice_scores, into = c("splice_score_3", "splice_score_5"), sep = ",")

# If necessary, clean up the new columns
final_exon_list$splice_score_3 <- gsub("[c()]", "", final_exon_list$splice_score_3)
final_exon_list$splice_score_5 <- gsub("[c()]", "", final_exon_list$splice_score_5)
final_exon_list$splice_score_3 <- as.numeric(final_exon_list$splice_score_3)
final_exon_list$splice_score_5 <- as.numeric(final_exon_list$splice_score_5)

final_exon_list<-calculate_GC_percent(final_exon_list,"sequence")

# Intron List features
final_intron_list$length<-events_info$LE_n[match(final_intron_list$EVENT, events_info$EVENT)]
final_intron_list$sequence<-events_info$Seq_A[match(final_intron_list$EVENT, events_info$EVENT)]

final_intron_list$splice_scores <- apply(final_intron_list, 1, function(row) {
  # Get the event value from the current row
  event_value <- row["EVENT"]

  # Call the function to extract the V3 values
  extract_V3_for_event(event_value, splice_scores)
})

# Unnest the list in V3_values into two separate columns
final_intron_list <- final_intron_list %>%
  unnest(cols = splice_scores) %>%
  separate(splice_scores, into = c("splice_score_3", "splice_score_5"), sep = ",")

# If necessary, clean up the new columns
final_intron_list$splice_score_3 <- gsub("[c()]", "", final_intron_list$splice_score_3)
final_intron_list$splice_score_5 <- gsub("[c()]", "", final_intron_list$splice_score_5)
final_intron_list$splice_score_3 <- as.numeric(final_intron_list$splice_score_3)
final_intron_list$splice_score_5 <- as.numeric(final_intron_list$splice_score_5)

final_intron_list<-calculate_GC_percent(final_intron_list,"sequence")

```

```{r final ANOVA list features extraction}
# ANOVA Exon List features
tao_anova_multgroups_exons_tab$length<-events_info$LE_n[match(tao_anova_multgroups_exons_tab$EVENT, events_info$EVENT)]
tao_anova_multgroups_exons_tab$sequence<-events_info$Seq_A[match(tao_anova_multgroups_exons_tab$EVENT, events_info$EVENT)]

tao_anova_multgroups_exons_tab$splice_scores <- apply(tao_anova_multgroups_exons_tab, 1, function(row) {
  # Get the event value from the current row
  event_value <- row["EVENT"]

  # Call the function to extract the V3 values
  extract_V3_for_event(event_value, splice_scores)
})

# Unnest the list in V3_values into two separate columns
tao_anova_multgroups_exons_tab <- tao_anova_multgroups_exons_tab %>%
  unnest(cols = splice_scores) %>%
  separate(splice_scores, into = c("splice_score_3", "splice_score_5"), sep = ",")

# If necessary, clean up the new columns
tao_anova_multgroups_exons_tab$splice_score_3 <- gsub("[c()]", "", tao_anova_multgroups_exons_tab$splice_score_3)
tao_anova_multgroups_exons_tab$splice_score_5 <- gsub("[c()]", "", tao_anova_multgroups_exons_tab$splice_score_5)
tao_anova_multgroups_exons_tab$splice_score_3 <- as.numeric(tao_anova_multgroups_exons_tab$splice_score_3)
tao_anova_multgroups_exons_tab$splice_score_5 <- as.numeric(tao_anova_multgroups_exons_tab$splice_score_5)

tao_anova_multgroups_exons_tab<-calculate_GC_percent(tao_anova_multgroups_exons_tab,"sequence")

# Look for unique events not in the pair-wise list
unique_tao_anova_multgroups_exons_tab<-tao_anova_multgroups_exons_tab[!tao_anova_multgroups_exons_tab$EVENT %in% final_exon_list$EVENT,]

# ANOVA Intron List features
tao_anova_multgroups_introns_tab$length<-events_info$LE_n[match(tao_anova_multgroups_introns_tab$EVENT, events_info$EVENT)]
tao_anova_multgroups_introns_tab$sequence<-events_info$Seq_A[match(tao_anova_multgroups_introns_tab$EVENT, events_info$EVENT)]

tao_anova_multgroups_introns_tab$splice_scores <- apply(tao_anova_multgroups_introns_tab, 1, function(row) {
  # Get the event value from the current row
  event_value <- row["EVENT"]

  # Call the function to extract the V3 values
  extract_V3_for_event(event_value, splice_scores)
})

# Unnest the list in V3_values into two separate columns
tao_anova_multgroups_introns_tab <- tao_anova_multgroups_introns_tab %>%
  unnest(cols = splice_scores) %>%
  separate(splice_scores, into = c("splice_score_3", "splice_score_5"), sep = ",")

# If necessary, clean up the new columns
tao_anova_multgroups_introns_tab$splice_score_3 <- gsub("[c()]", "", tao_anova_multgroups_introns_tab$splice_score_3)
tao_anova_multgroups_introns_tab$splice_score_5 <- gsub("[c()]", "", tao_anova_multgroups_introns_tab$splice_score_5)
tao_anova_multgroups_introns_tab$splice_score_3 <- as.numeric(tao_anova_multgroups_introns_tab$splice_score_3)
tao_anova_multgroups_introns_tab$splice_score_5 <- as.numeric(tao_anova_multgroups_introns_tab$splice_score_5)

tao_anova_multgroups_introns_tab<-calculate_GC_percent(tao_anova_multgroups_introns_tab,"sequence")

# Look for unique events not in the pair-wise list
unique_tao_anova_multgroups_introns_tab<-tao_anova_multgroups_introns_tab[!tao_anova_multgroups_introns_tab$EVENT %in% final_intron_list$EVENT,]

```

## Gene Ontology of Filtered Splicing Events

```{r gene ontology, fig.width=10, fig.height=8}
exon_go <- bitr(final_exon_list$GENE, fromType = "ALIAS", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
names(exon_go)<-c("GENE","ENTREZID")
final_exon_list <- final_exon_list %>%
  left_join(as.data.frame(exon_go), by = "GENE")


# GO Enrichment Analysis
go_enrich_exon <- enrichGO(gene = exon_go$ENTREZID,
                      OrgDb = org.Mm.eg.db,
                      ont = "ALL",
                      pAdjustMethod = "BH",
                      pvalueCutoff = 0.05,
                      qvalueCutoff = 0.05)
speckle_related_genes<-strsplit(head(go_enrich_exon)[which(head(go_enrich_exon)$Description=="non-membrane-bounded organelle assembly"), "geneID"], "/")[[1]]
final_exon_list$GO_speckle<-ifelse(final_exon_list$ENTREZID %in% speckle_related_genes, "TRUE", "FALSE")

intron_go <- bitr(final_intron_list$GENE, fromType = "ALIAS", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
names(intron_go)<-c("GENE","ENTREZID")
final_intron_list <- final_intron_list %>%
  left_join(as.data.frame(intron_go), by = "GENE")


# GO Enrichment Analysis
go_enrich_intron <- enrichGO(gene = intron_go$ENTREZID,
                      OrgDb = org.Mm.eg.db,
                      ont = "ALL",
                      pAdjustMethod = "BH",
                      pvalueCutoff = 0.05,
                      qvalueCutoff = 0.05)
speckle_related_genes<-strsplit(head(go_enrich_intron)[which(head(go_enrich_exon)$Description=="non-membrane-bounded organelle assembly"), "geneID"], "/")[[1]]
final_intron_list$GO_speckle<-ifelse(final_intron_list$ENTREZID %in% speckle_related_genes, "TRUE", "FALSE")



gene_entrez <- bitr(union(final_exon_list$GENE, final_intron_list$GENE), fromType = "ALIAS", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
gene_entrez_go <- enrichGO(gene = gene_entrez$ENTREZID,
                      OrgDb = org.Mm.eg.db,
                      ont = "ALL",
                      pAdjustMethod = "BH",
                      pvalueCutoff = 0.05,
                      qvalueCutoff = 0.05)

# Polished GO dot plot
go_plot <- dotplot(
  gene_entrez_go,
  showCategory = 20
) +
  ggtitle("<b style='font-size:18px;'>GO Enrichment Analysis</b>") +
  labs(
    caption = paste0("Created by Andrés Gordo Ortiz on ", Sys.Date()),
    x = "Gene Ratio",
    y = "GO Terms"
  ) +
  theme_minimal(base_family = "sans") +
  theme(
    plot.title = element_markdown(hjust = 0.5),  # Center and style title
    axis.text.y = element_text(size = 13, color = "black"),  # Clear, professional y-axis labels
    axis.text.x = element_text(size = 12, color = "black"),  # Readable x-axis labels
    axis.title = element_text(size = 15),  # Title size enhancement
    panel.grid.major = element_line(color = "gray90"),  # Subtle gridlines
    panel.background = element_rect(fill = "white"),  # Clean background
    plot.caption = element_text(size = 10, hjust = 1, color = "gray50")  # Subtitle for the caption
  ) +
  scale_color_paletteer_c("viridis::viridis", name = "P-adjust") +  # Improve coloring for better accessibility
  scale_y_discrete(guide = guide_axis(n.dodge = 1))  # Handle overlapping labels


go_plot
```
## Enrichment Analysis with EnrichR of Candidate Genes { .tabset}

```{r pladb enrichr}
enrichdata<-enrichr(unique(c(final_exon_list$GENE, final_intron_list$GENE)), databases = c("GO_Biological_Process_2023","GO_Cellular_Component_2023","GO_Molecular_Function_2023"))
```

### GO Biological Process

```{r pladb bioprocess, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[1]])
```

### GO Cellular Component

```{r pladb cellcomponent, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[2]])
```

### GO Molecular Function

```{r pladb molfunction, fig.width=10, fig.height=8}
plotEnrich(enrichdata[[3]])
```


```{r ENTREZ ANOVA}
exon_anova_go <- bitr(unique_tao_anova_multgroups_exons_tab$GENE, fromType = "ALIAS", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
names(exon_anova_go)<-c("GENE","ENTREZID")
unique_tao_anova_multgroups_exons_tab <- unique_tao_anova_multgroups_exons_tab %>%
  left_join(as.data.frame(exon_anova_go), by = "GENE")

intron_anova_go <- bitr(unique_tao_anova_multgroups_introns_tab$GENE, fromType = "ALIAS", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
names(intron_anova_go)<-c("GENE","ENTREZID")
unique_tao_anova_multgroups_introns_tab <- unique_tao_anova_multgroups_introns_tab %>%
  left_join(as.data.frame(intron_anova_go), by = "GENE")

```


## Speckle Gene Groups

```{r Wun et al. list of genes}
groupA_genelist <- read_excel("Table S1_GroupABC gene list.xlsx",
    sheet = "Group A", skip = 1)[,-1]$Geneid %>%
  lapply(function(x) gsub("\\.\\d+", "", x)) %>%
  unlist()

groupB_genelist <- read_excel("Table S1_GroupABC gene list.xlsx",
    sheet = "Group B")[,-1]$Geneid %>%
  lapply(function(x) gsub("\\.\\d+", "", x)) %>%
  unlist()

groupC_genelist <- read_excel("Table S1_GroupABC gene list.xlsx",
    sheet = "Group C")[,-1]$Geneid %>%
  lapply(function(x) gsub("\\.\\d+", "", x)) %>%
  unlist()


human = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
attributes = c("ensembl_gene_id", "mmusculus_homolog_ensembl_gene", "mmusculus_homolog_perc_id_r1")
orth.mouse = getBM(attributes, values=TRUE, mart = human, uniqueRows=TRUE)

groupA_genelist_mouse <- orth.mouse[orth.mouse$ensembl_gene_id %in% groupA_genelist, "mmusculus_homolog_ensembl_gene"] %>%
  unlist()
groupB_genelist_mouse <- orth.mouse[orth.mouse$ensembl_gene_id %in% groupB_genelist, "mmusculus_homolog_ensembl_gene"] %>%
  unlist()
groupC_genelist_mouse <- orth.mouse[orth.mouse$ensembl_gene_id %in% groupC_genelist, "mmusculus_homolog_ensembl_gene"] %>%
  unlist()

groupA_genelist_mouse <- bitr(groupA_genelist_mouse, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
groupB_genelist_mouse <- bitr(groupB_genelist_mouse, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)
groupC_genelist_mouse <- bitr(groupC_genelist_mouse, fromType = "ENSEMBL", toType = "ENTREZID", OrgDb = org.Mm.eg.db)

# Exon list analysis
final_exon_list$GroupA <- ifelse(final_exon_list$ENTREZID %in% groupA_genelist_mouse$ENTREZID, "TRUE", "FALSE")

final_exon_list$GroupB <- ifelse(final_exon_list$ENTREZID %in% groupB_genelist_mouse$ENTREZID, "TRUE", "FALSE")

final_exon_list$GroupC <- ifelse(final_exon_list$ENTREZID %in% groupC_genelist_mouse$ENTREZID, "TRUE", "FALSE")

# Intron list analysis
final_intron_list$GroupA <- ifelse(final_intron_list$ENTREZID %in% groupA_genelist_mouse$ENTREZID, "TRUE", "FALSE")

final_intron_list$GroupB <- ifelse(final_intron_list$ENTREZID %in% groupB_genelist_mouse$ENTREZID, "TRUE", "FALSE")

final_intron_list$GroupC <- ifelse(final_intron_list$ENTREZID %in% groupC_genelist_mouse$ENTREZID, "TRUE", "FALSE")


# ANOVA Exon list analysis
unique_tao_anova_multgroups_exons_tab$GroupA <- ifelse(unique_tao_anova_multgroups_exons_tab$ENTREZID %in% groupA_genelist_mouse$ENTREZID, "TRUE", "FALSE")

unique_tao_anova_multgroups_exons_tab$GroupB <- ifelse(unique_tao_anova_multgroups_exons_tab$ENTREZID %in% groupB_genelist_mouse$ENTREZID, "TRUE", "FALSE")

unique_tao_anova_multgroups_exons_tab$GroupC <- ifelse(unique_tao_anova_multgroups_exons_tab$ENTREZID %in% groupC_genelist_mouse$ENTREZID, "TRUE", "FALSE")


# ANOVA intron list analysis
unique_tao_anova_multgroups_introns_tab$GroupA <- ifelse(unique_tao_anova_multgroups_introns_tab$ENTREZID %in% groupA_genelist_mouse$ENTREZID, "TRUE", "FALSE")

unique_tao_anova_multgroups_introns_tab$GroupB <- ifelse(unique_tao_anova_multgroups_introns_tab$ENTREZID %in% groupB_genelist_mouse$ENTREZID, "TRUE", "FALSE")

unique_tao_anova_multgroups_introns_tab$GroupC <- ifelse(unique_tao_anova_multgroups_introns_tab$ENTREZID %in% groupC_genelist_mouse$ENTREZID, "TRUE", "FALSE")
```


```{r final arrange}
final_exon_list <- final_exon_list[!duplicated(final_exon_list$EVENT), ] %>%
  arrange(desc(GroupA), GroupC,desc(abs(avg_deltapsi)))

final_intron_list<-arrange(final_intron_list, desc(GroupA), GroupC,desc(abs(avg_deltapsi)))

unique_tao_anova_multgroups_introns_tab<-arrange(unique_tao_anova_multgroups_introns_tab, desc(GroupA), GroupC,desc(abs(medianBetweens)))

unique_tao_anova_multgroups_exons_tab<-arrange(unique_tao_anova_multgroups_exons_tab, desc(GroupA), GroupC,desc(abs(medianBetweens)))
```



## Event Densities { .tabset}

### Exons

```{r densities_per_event, warning=FALSE, message=FALSE, fig.width=16, fig.height=8}
event_names <- c("MmuEX0024626", "MmuEX0024625", "MmuEX0039030",
                 "MmuEX0039029", "MmuEX0030454", "MmuEX0048979",
                 "MmuEX1009295", "MmuEX0034296")

# Generate individual plots and store them in a list
plots <- lapply(event_names, function(eventID) {
  # Extract the corresponding gene name for the event
  geneName <- final_exon_list$GENE[final_exon_list$EVENT == eventID]

  # Generate the plot
  tdensities <- plotIndividualDensitiesList(
    eventID = eventID,
    npoints = 500,
    psitable = tao_exons$PSI,
    qualtable = tao_exons$Qual,
    groupList = groupList_tao,
    maxDevTable = maxDevSimulationN100,
    seed = TRUE,
    CoverageWeight = FALSE
  )

  # Add titles and themes
  tdensities +
    theme_minimal(base_family = font) +
    theme(
      plot.title = element_text(size = 14, face = "bold"),  # Title size
      axis.text = element_text(size = 12),                # Axis label size
      axis.title = element_text(size = 14),               # Axis text size
      axis.text.y = element_blank(),                      # Remove Y-axis text
      axis.title.y = element_blank(),                     # Remove Y-axis title
      axis.ticks.y = element_blank()                      # Remove Y-axis tick
    ) +
    ggtitle(paste(geneName, eventID))
})

# Combine all plots with patchwork
final_plot_exons <- wrap_plots(plots, ncol = 4, byrow = TRUE) +
  plot_layout(guides = 'collect') +
  plot_annotation(
    caption = paste0("Created by AG on ", Sys.Date())
  )
# Display the combined plot
final_plot_exons
```

#### Explanation

**Itga7:**
An isoform switch is observed between exons MmuEX0024625 (excluded) and MmuEX0024626 (included) during myogenesis, with similar ΔPSI values within the same module. The Itga7 gene encodes a protein of the integrin alpha chain family, functioning as a receptor for laminin-1 and playing roles in cell migration, differentiation, and morphogenesis. The lost exon (MmuEX0024625) has over 70% GC content, making it a "hard" exon. Its exclusion may be linked to the reduced number of nuclear speckles during myogenesis, which disrupts their fine-tuned structural support. The gained exon (MmuEX0024626) has lower GC content (49%), making it "soft." Notably, these exons are non-overlapping.

**Rbfox2:**
This gene encodes an RNA-binding protein that regulates alternative splicing via binding to the UGCAUG motif. During myogenesis, an isoform switch occurs (MmuEX0039029 > MmuEX0039030), with equivalent ΔPSI values in the module. The excluded exon (MmuEX0039029) has higher GC content (47%) and a lower splice site score (4.5) than the included exon (MmuEX0039030, 37% GC, 10 ssc). These findings suggest that the exclusion of "hard" exons and inclusion of "soft" exons may be associated with speckle disruption during myogenesis. Both exons are short (~45 bp), and the excluded exon disrupts the ORF, enabling functional protein expression. Additionally, exon MmuEX0039032 is excluded in this context.

**Myo18a:**
The included exon (MmuEX0030454) shows a high ΔPSI (0.595), low splice site scores (3 and -2.9), and high GC content (64%). This gene encodes a protein involved in Golgi-cytoskeleton interactions and lamellar actomyosin bundle assembly, which are critical for cell migration. Flanking exons (MmuEX0030453 upstream and MmuEX0030449 downstream) are also included. Both are short (MmuEX0030449, 36 bp) and exhibit weak splice site scores and high GC content (~72%).

**Trip10:**
This gene encodes a protein linked to actin cytoskeleton organization, endocytosis, and signal transduction, with implications as a biomarker for Huntington’s disease. The included exon has a high ΔPSI (0.433), low splice site scores (1.65 and 9.65), high GC content (65%), and is short (168 bp). It is part of the Group A list.

**Ehbp1l1:**
The included exon (ΔPSI: 0.314) is short (183 bp), exhibits high GC content (62.8%), and has weak splice site scores (-1.08 and 9.46). This gene is associated with actin cytoskeleton organization and is located in Group A.

Negative Control:

Tpm1: Assigned to Group C.

### Introns

```{r densities_per_event introns, out.width="100%", warning=FALSE, message=FALSE}
event_names <- c("MmuINT0172005", "MmuINT0168360")

# Generate individual plots and store them in a list
plots <- lapply(event_names, function(eventID) {
  # Extract the corresponding gene name for the event
  geneName <- final_intron_list$GENE[final_intron_list$EVENT == eventID]

  # Generate the plot
  tdensities <- plotIndividualDensitiesList(
    eventID = eventID,
    npoints = 500,
    psitable = tao_introns$PSI,
    qualtable = tao_introns$Qual,
    groupList = groupList_tao,
    maxDevTable = maxDevSimulationN100,
    seed = TRUE,
    CoverageWeight = FALSE
  )

  # Add titles and themes
  tdensities +
    theme_minimal(base_family = font) +
    theme(
      plot.title = element_text(size = 14, face = "bold"),  # Title size
      axis.text = element_text(size = 12),                # Axis label size
      axis.title = element_text(size = 14),               # Axis text size
      axis.text.y = element_blank(),                      # Remove Y-axis text
      axis.title.y = element_blank(),                     # Remove Y-axis title
      axis.ticks.y = element_blank()                      # Remove Y-axis tick
    ) +
    ggtitle(paste(geneName, eventID))
})

# Combine all plots with patchwork
final_plot_introns <- wrap_plots(plots) +
  plot_annotation(
    caption = paste0("Created by AG on ", Sys.Date())
  )
# Display the combined plot
final_plot_introns

```

#### Explanation

**Usp5 (MmuINT0172005):**
The intron of Usp5 (ubiquitin-specific peptidase 5) shows significant splicing activity during myogenesis, with a splicing increase of over 50%. It has a weak 3' splice site score (4.56) and a GC content above 50%. Gene Ontology (GO) annotations link Usp5 to membraneless organelles. Previous studies, including the Science paper and findings on its human ortholog (USP42), highlight its relevance to nuclear speckle-associated splicing. Knockdown (KD) of USP42 was shown to reduce SC35 nuclear speckle markers (see PMC8329168). Inclusion of this intron disrupts the open reading frame (ORF), suggesting a functional impact. This intron represents a promising candidate for further investigation.

### ANOVA Exons

```{r densities_per_event ANOVA exons, fig.width=16, fig.height=8, warning=FALSE, message=FALSE}
event_names <- c("MmuEX0034298","MmuEX0034278","MmuEX0034277","MmuEX0007973", "MmuEX0044362","MmuEX0044363","MmuEX0048341", "MmuEX0005349")

# Generate individual plots and store them in a list
plots <- lapply(event_names, function(eventID) {
  # Extract the corresponding gene name for the event
  geneName <- unique_tao_anova_multgroups_exons_tab$GENE[unique_tao_anova_multgroups_exons_tab$EVENT == eventID]

  # Generate the plot
  tdensities <- plotIndividualDensitiesList(
    eventID = eventID,
    npoints = 500,
    psitable = tao_exons$PSI,
    qualtable = tao_exons$Qual,
    groupList = groupList_tao,
    maxDevTable = maxDevSimulationN100,
    seed = TRUE,
    CoverageWeight = FALSE
  )

  # Add titles and themes
  tdensities +
    theme_minimal(base_family = font) +
    theme(
      plot.title = element_text(size = 14, face = "bold"),  # Title size
      axis.text = element_text(size = 12),                # Axis label size
      axis.title = element_text(size = 14),               # Axis text size
      axis.text.y = element_blank(),                      # Remove Y-axis text
      axis.title.y = element_blank(),                     # Remove Y-axis title
      axis.ticks.y = element_blank()                      # Remove Y-axis tick
    ) +
    ggtitle(paste(geneName, eventID))
})

# Combine all plots with patchwork
final_plot_anova_exons <- wrap_plots(plots, ncol = 4, byrow = TRUE) +
  plot_layout(guides = 'collect') +
  plot_annotation(
    caption = paste0("Created by AG on ", Sys.Date())
  )
# Display the combined plot
final_plot_anova_exons

```



### ANOVA Introns

```{r densities_per_event ANOVA introns, out.width="100%", warning=FALSE, message=FALSE}
event_names <- c("MmuINT0015093","MmuINT1026524")

# Generate individual plots and store them in a list
plots <- lapply(event_names, function(eventID) {
  # Extract the corresponding gene name for the event
  geneName <- unique_tao_anova_multgroups_introns_tab$GENE[unique_tao_anova_multgroups_introns_tab$EVENT == eventID]

  # Generate the plot
  tdensities <- plotIndividualDensitiesList(
    eventID = eventID,
    npoints = 500,
    psitable = tao_introns$PSI,
    qualtable = tao_introns$Qual,
    groupList = groupList_tao,
    maxDevTable = maxDevSimulationN100,
    seed = TRUE,
    CoverageWeight = FALSE
  )

  # Add titles and themes
  tdensities +
    theme_minimal(base_family = font) +
    theme(
      plot.title = element_text(size = 14, face = "bold"),  # Title size
      axis.text = element_text(size = 12),                # Axis label size
      axis.title = element_text(size = 14),               # Axis text size
      axis.text.y = element_blank(),                      # Remove Y-axis text
      axis.title.y = element_blank(),                     # Remove Y-axis title
      axis.ticks.y = element_blank()                      # Remove Y-axis tick
    ) +
    ggtitle(paste(geneName, eventID))
})

# Combine all plots with patchwork
final_plot_anova_introns <- wrap_plots(plots, ncol = 2, byrow = TRUE) +
  plot_layout(guides = 'collect') +
  plot_annotation(
    caption = paste0("Created by AG on ", Sys.Date())
  )
# Display the combined plot
final_plot_anova_introns

```

# Final Candidates List Sorted { .tabset}

## Exons

```{r final sorted exons table}
# Render DataTable with enhancements
datatable(
  select(final_exon_list, -ENTREZID,-sequence, -avg_Pdiff, -avg_FDR, -COORD),
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
)


write.csv(final_exon_list,
          file = file.path(output_dir, paste0("sorted_final_exon_list_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

## Introns

```{r final sorted intron table}
# Render DataTable with enhancements
datatable(
  select(final_intron_list, -ENTREZID,-sequence, -avg_Pdiff, -avg_FDR, -COORD),
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
)


write.csv(final_intron_list,
          file = file.path(output_dir, paste0("sorted_final_intron_list_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

## ANOVA Exons

```{r final sorted anova exons table}
# Render DataTable with enhancements
datatable(
  select(unique_tao_anova_multgroups_exons_tab, -ENTREZID,-sequence, -Pdiff, -COORD),
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
)


write.csv(unique_tao_anova_multgroups_exons_tab,
          file = file.path(output_dir, paste0("sorted_final_anova_exons_list_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```


## ANOVA Introns

```{r final sorted anova introns table}
# Render DataTable with enhancements
datatable(
  select(unique_tao_anova_multgroups_introns_tab, -ENTREZID,-sequence, -Pdiff, -COORD),
  options = list(
    pageLength = 10,                      # Rows per page
    autoWidth = TRUE,                     # Adjust column widths automatically
    dom = 'Bfrtip',                       # Add buttons for export
    buttons = c("copy", "csv", "excel", "pdf"),  # Simplified button definitions
    columnDefs = list(
      list(targets = "_all", className = "dt-center"),    # Center-align all columns
      list(
        targets = 3,  # Highlight significant Pdiff
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && parseFloat(data) > 0.99) {
               return '<span style=\"color: green; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      ),
      list(
        targets = 4,  # Highlight large deltapsi values
        render = JS(
          "function(data, type, row) {
             if (type === 'display' && Math.abs(parseFloat(data)) > 0.5) {
               return '<span style=\"color: red; font-weight: bold;\">' + data + '</span>';
             }
             return data;
           }"
        )
      )
    )
  ),
  rownames = FALSE,                       # Disable row names
  extensions = "Buttons"                  # Enable export buttons
)


write.csv(unique_tao_anova_multgroups_introns_tab,
          file = file.path(output_dir, paste0("sorted_final_anova_introns_list_", format(Sys.Date(), "%Y%m%d"), ".csv")),
          row.names = FALSE)
```

# Splicing Dynamics Heatmap

```{r heatmap prep, results='hide'}
# Extract all events
tao_all <- filterEvents(
  tao_events,
  types = c("C1", "C2", "C3", "S", "MIC", "IR"),
  N = 3
)

# Convert PSI values to a matrix and set row names
tao_matrix <- tao_all$PSI[, 7:18] %>%
  as.matrix()
rownames(tao_matrix) <- tao_all$PSI$EVENT

# Filter rows based on the final event lists
filtered_events <- unique(c(
  final_exon_list$EVENT,
  final_intron_list$EVENT,
  unique_tao_anova_multgroups_exons_tab$EVENT,
  unique_tao_anova_multgroups_introns_tab$EVENT
))
tao_matrix <- tao_matrix[rownames(tao_matrix) %in% filtered_events, ]

# Arrange columns based on metadata
metadata_tao <- arrange(metadata_tao, experiment_title)
tao_matrix <- tao_matrix[, metadata_tao$run_accession]

# Create a dendrogram for the columns
col_dend <- hclust(dist(t(tao_matrix))) %>%
  as.dendrogram() %>%
  color_branches(k = 4) # Color branches with 4 clusters

# Check if row names contain "EX"
contains_EX <- grepl("EX", rownames(tao_matrix))

# Define an improved color gradient for the heatmap
col_fun <- colorRamp2(
  c(0, 50, 100),
  c("purple", "white", "orange")
)

number_splices<-12

# Assign colors based on the condition
ht<-Heatmap(tao_matrix, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns  = col_dend,
column_title = "C2C12 Samples at Different Stages",
     , row_names_gp = gpar(col =row_colors, fontsize = 10),
  column_names_rot = 45,
column_labels = metadata_tao$experiment_title,
  column_dend_reorder=c(1,2,3,4,5,6,7,8,9,10,11,12),
  row_km = number_splices,
  row_dend_reorder = T,
rect_gp = gpar(col = "white", lwd = 0.3),  column_names_gp = gpar(fontsize = 8)  )

ht = draw(ht); clustered_events<-row_order(ht)

reference_table<-data.frame(EVENT=c(final_exon_list$EVENT,
  final_intron_list$EVENT,
  unique_tao_anova_multgroups_exons_tab$EVENT,
  unique_tao_anova_multgroups_introns_tab$EVENT),GENE=c(final_exon_list$GENE,
  final_intron_list$GENE,
  unique_tao_anova_multgroups_exons_tab$GENE,
  unique_tao_anova_multgroups_introns_tab$GENE))

text_list<-list()
# Loop through clustered events and assign dynamic names
for (i in 1:length(clustered_events)) {
  enrich_events <- enrichr(
    reference_table$GENE[reference_table$EVENT %in% rownames(tao_matrix)[clustered_events[[i]]]],
    databases = c("GO_Biological_Process_2023", "GO_Cellular_Component_2023", "GO_Molecular_Function_2023")
  )

  # Assign the dynamic name and value
  text_list[[paste0("text", i)]] <- paste(
    enrich_events$GO_Cellular_Component_2023$Term[1],
    enrich_events$GO_Cellular_Component_2023$Term[2],
    enrich_events$GO_Cellular_Component_2023$Term[3],
    sep = "; \n"
  )
}

ha = rowAnnotation(foo = anno_empty(border = FALSE,
    width = max_text_width(unlist(text_list)) + unit(4, "mm")))

```

### Heatmap showcasing the PSI of every candidate EX and IN

**Note**: Gene ontology of *Cellular Component* for each of the clustered blocks (splicing events that the *pearson* algorithm has found they behave similarly) appears on the right.
```{r heatmap_plot, fig.width=16, fig.height=12, out.width="100%", echo=TRUE,dpi=300}
Heatmap(
  tao_matrix, name = "PSI",
  clustering_distance_rows = "pearson",
  col = col_fun,
  cluster_columns  = col_dend,
  column_title = "C2C12 Samples at Different Stages of Development",
  row_title = "Splicing Events",
  column_names_rot = 45,
  column_labels = metadata_tao$experiment_title,
  column_dend_reorder = c(1:12),
  row_km = number_splices,
  row_dend_reorder = TRUE,
  right_annotation = ha,
  rect_gp = gpar(col = "white", lwd = 0.3),
  column_names_gp = gpar(fontsize = 12),
  show_row_names = FALSE,

)

for (i in seq_along(clustered_events)) {
  decorate_annotation("foo", slice = i, {
    grid.rect(x = 0, width = unit(2, "mm"), gp = gpar(fill = i, col = NA), just = "left")
    grid.text(paste(text_list[[i]], collapse = "\n"), x = unit(4, "mm"), just = "left")
  })
}

```

# System Settings

```{r session info}
sessionInfo()
```


